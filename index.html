<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- PDF Export Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <style>
    /* General Styles */
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Arial', sans-serif;
    background-color: #f5f7fa;
    color: #2d3748;
    line-height: 1.4;
    margin: 0;
    padding: 20px;
    min-height: 100vh;
}

/* Header */
h1 {
    font-size: 2.5em;
    margin: 0 0 25px 0;
    font-weight: 700;
    color: #2d3748;
    text-align: center;
}

/* Compact Layout Container */
.input-row {
    display: flex;
    align-items: center;
    gap: 20px;
    margin-bottom: 15px;
    flex-wrap: wrap;
}

.input-row-2 {
    display: flex;
    align-items: center;
    gap: 20px;
    margin-bottom: 15px;
    flex-wrap: wrap;
}

/* Labels */
label {
    font-size: 14px;
    font-weight: 600;
    color: #4a5568;
    white-space: nowrap;
}

/* File Input Styling */
input[type="file"] {
    padding: 8px 12px;
    border: 2px solid #e9ecef;
    border-radius: 8px;
    background-color: #f5f7fa;
    font-size: 14px;
    color: #4a5568;
    cursor: pointer;
    transition: all 0.3s ease;
    width: auto;
    min-width: fit-content;
}

input[type="file"]:hover {
    border-color: #667eea;
    box-shadow: 0 2px 8px rgba(102, 126, 234, 0.15);
    transform: translateY(-1px);
}

/* Select Dropdown Styling */
select {
    padding: 8px 12px;
    border: 2px solid #e9ecef;
    border-radius: 8px;
    background-color: #f5f7fa;
    font-size: 14px;
    color: #4a5568;
    cursor: pointer;
    transition: all 0.3s ease;
    width: auto;
    min-width: fit-content;
}

select:hover {
    border-color: #667eea;
    box-shadow: 0 2px 8px rgba(102, 126, 234, 0.15);
    transform: translateY(-1px);
}

select:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

/* Advanced Toggle Container */
.toggle-container {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 8px 12px;
    background-color: #f5f7fa;
    border-radius: 8px;
    border: 2px solid #e9ecef;
    transition: all 0.3s ease;
    width: fit-content;
}

.toggle-container:hover {
    border-color: #667eea;
    box-shadow: 0 2px 8px rgba(102, 126, 234, 0.15);
    transform: translateY(-1px);
}

/* Toggle Switch - Smaller */
.toggle-switch {
    position: relative;
    display: inline-block;
    width: 48px;
    height: 26px;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #cbd5e0;
    transition: 0.3s ease;
    border-radius: 26px;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
}

.slider:before {
    position: absolute;
    content: "";
    height: 20px;
    width: 20px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: 0.3s ease;
    border-radius: 50%;
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
}

input:checked + .slider {
    background: linear-gradient(45deg, #667eea, #764ba2);
    box-shadow: 0 0 8px rgba(102, 126, 234, 0.4);
}

input:checked + .slider:before {
    transform: translateX(22px);
}

.toggle-label {
    font-size: 14px;
    font-weight: 600;
    color: #4a5568;
    user-select: none;
    cursor: pointer;
    transition: color 0.3s ease;
    margin: 0;
}

.toggle-container:hover .toggle-label {
    color: #667eea;
}

/* Regular Checkbox Styling */
input[type="checkbox"]:not(.toggle-switch input) {
    appearance: none;
    width: 16px;
    height: 16px;
    border: 2px solid #e9ecef;
    border-radius: 4px;
    background-color: #f5f7fa;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    margin-right: 8px;
    vertical-align: middle;
}

input[type="checkbox"]:not(.toggle-switch input):hover {
    border-color: #667eea;
    box-shadow: 0 1px 4px rgba(102, 126, 234, 0.15);
    transform: translateY(-1px);
}

input[type="checkbox"]:not(.toggle-switch input):checked {
    background: linear-gradient(45deg, #667eea, #764ba2);
    border-color: #667eea;
}

input[type="checkbox"]:not(.toggle-switch input):checked::after {
    content: 'âœ“';
    position: absolute;
    color: white;
    font-weight: bold;
    font-size: 12px;
    top: -1px;
    left: 1px;
}

/* Checkbox Label */
label[for="troubleshootingToggle"] {
    font-size: 14px;
    vertical-align: middle;
}

/* Button Styling */
button {
    background: #2d2d2d;
    color: white;
    padding: 8px 16px;
    border: none;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
    margin-right: 15px;
    width: fit-content;
}

button:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
}

button:active {
    transform: translateY(0);
}

/* PDF Download Button */
.pdf-download-btn {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    margin-bottom: 15px;
    display: inline-flex;
    align-items: center;
    gap: 8px;
}

.pdf-download-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(102, 126, 234, 0.5);
}

.pdf-download-btn:active {
    transform: translateY(0);
}

.pdf-download-btn::before {
    content: 'ðŸ“„';
    font-size: 16px;
}

/* Results Section */
#results {
    margin-top: 25px;
    padding: 20px;
    background-color: #f5f7fa;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

/* Analysis Results Heading */
#results h2 {
    color: #2d3748;
    font-size: 1.8em;
    margin-bottom: 15px;
}

/* Table Styles */
table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 15px;
    background-color: #f5f7fa;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
}

th, td {
    padding: 12px 15px;
    text-align: left;
    border-bottom: 1px solid #e2e8f0;
    font-size: 14px;
}

th {
    background-color: #edf2f7;
    font-weight: 600;
    color: #2d3748;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    border-bottom: 2px solid #e2e8f0;
}

tr {
    transition: all 0.3s ease;
    background-color: #f5f7fa;
}

tr:hover {
    background: linear-gradient(135deg, #f0f4ff 0%, #e6f3ff 100%);
    transform: translateX(4px);
    box-shadow: 4px 0 12px rgba(102, 126, 234, 0.1);
    border: 2px solid #667eea;
    border-radius: 8px;
}

tr:nth-child(even) {
    background-color: #edf2f7;
}

tr:nth-child(even):hover {
    background: linear-gradient(135deg, #f0f4ff 0%, #e6f3ff 100%);
}

/* Responsive Design */
@media (max-width: 768px) {
    body {
        padding: 15px;
    }
    
    h1 {
        font-size: 2em;
    }
    
    .input-row, .input-row-2 {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
    }
    
    input[type="file"], select {
        width: 100%;
    }
    
    .toggle-container {
        width: 100%;
        justify-content: center;
    }
    
    button {
        width: 100%;
        margin: 10px 0;
    }
}

/* Meeting Tabs Container */
.meeting-tabs-container {
    position: sticky;
    top: 0;
    z-index: 1000;
    background: #f5f7fa;
    padding: 10px 0;
    border-bottom: 2px solid #e9ecef;
    margin-bottom: 10px;
}

.meeting-tabs {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
}

.meeting-tab {
    background: #2d2d2d;
    color: white;
    padding: 10px 15px;
    border-radius: 8px 8px 0 0;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    border: 2px solid transparent;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 10px;
}

.meeting-tab:hover {
    background: #3d3d3d;
    transform: translateY(-2px);
}

.meeting-tab.active {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-bottom: 2px solid #f5f7fa;
}

.tab-close {
    background: rgba(255, 255, 255, 0.2);
    border: none;
    color: white;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 14px;
    line-height: 1;
    transition: all 0.2s ease;
}

.tab-close:hover {
    background: rgba(255, 0, 0, 0.6);
    transform: scale(1.1);
}

/* Race Navigation Bar */
.race-nav-container {
    position: sticky;
    top: 60px;
    z-index: 999;
    background: #ffffff;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    margin-bottom: 20px;
}

.race-nav-buttons {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-bottom: 15px;
}

.race-nav-button {
    background: #f5f7fa;
    color: #4a5568;
    padding: 8px 15px;
    border: 2px solid #e9ecef;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s ease;
}

.race-nav-button:hover {
    background: #667eea;
    color: white;
    border-color: #667eea;
    transform: translateY(-2px);
}

.race-nav-button.current {
    background: linear-gradient(45deg, #667eea, #764ba2);
    color: white;
    border-color: #667eea;
}

.action-buttons {
    display: flex;
    gap: 10px;
    padding-top: 10px;
    border-top: 1px solid #e9ecef;
}

.action-button {
    background: #2d2d2d;
    color: white;
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.action-button:hover {
    background: #667eea;
    transform: translateY(-1px);
}

/* Race Container */
.race-container {
    margin-bottom: 30px;
}

/* Race Dashboard */
.race-dashboard {
    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
color: white;
    padding: 20px;
    border-radius: 12px;
    margin-bottom: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.race-dashboard:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
}

.race-dashboard-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 15px;
}

.race-title {
    font-size: 1.5em;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 10px;
}

.collapse-arrow {
    font-size: 1.2em;
    transition: transform 0.3s ease;
}

.collapse-arrow.collapsed {
    transform: rotate(-90deg);
}

/* Top 3 Horses Display */
.top-horses {
    margin-bottom: 15px;
}

.horse-row {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 10px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    margin-bottom: 8px;
}

.position-badge {
    width: 35px;
    height: 35px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 16px;
    color: white;
    flex-shrink: 0;
}

.position-badge.first {
    background: linear-gradient(135deg, #FFD700, #FFA500);
    box-shadow: 0 2px 8px rgba(255, 215, 0, 0.4);
}

.position-badge.second {
    background: linear-gradient(135deg, #C0C0C0, #A8A8A8);
    box-shadow: 0 2px 8px rgba(192, 192, 192, 0.4);
}

.position-badge.third {
    background: linear-gradient(135deg, #CD7F32, #B8733E);
    box-shadow: 0 2px 8px rgba(205, 127, 50, 0.4);
}

.horse-name {
    font-weight: 700;
    font-size: 1.1em;
    min-width: 150px;
}

.horse-stats {
    display: flex;
    gap: 20px;
    font-size: 0.95em;
}

.stat-item {
    display: flex;
    gap: 5px;
}

.stat-label {
    opacity: 0.8;
}

.stat-value {
    font-weight: 600;
}

/* Race Stats Bar */
.race-stats-bar {
    display: flex;
    gap: 30px;
    padding: 12px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    font-size: 0.95em;
}

.race-stat {
    display: flex;
    gap: 8px;
}

.race-stat-label {
    opacity: 0.8;
}

.race-stat-value {
    font-weight: 700;
}

.worst-score {
    color: #ff6b6b;
}

/* Race Table Container */
.race-table-container {
    overflow: hidden;
    transition: max-height 0.3s ease;
}

.race-table-container.collapsed {
    max-height: 0;
}

.race-table-container.expanded {
    max-height: 5000px;
}

/* Sticky Race Header (when scrolling) */
.sticky-race-header {
    position: fixed;
    top: 60px;
    left: 0;
    right: 0;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 12px 20px;
    font-weight: 600;
    font-size: 1.1em;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    z-index: 998;
    display: none;
}

.sticky-race-header.visible {
    display: block;
}

/* Meeting Content Container */
.meeting-content {
    display: none;
}

.meeting-content.active {
    display: block;
}

/* ====== FILTER BAR STYLES ====== */
.filter-bar-container {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    padding: 20px;
    border-radius: 12px;
    margin-bottom: 20px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.filter-bar-header {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
    flex-wrap: wrap;
}

.filter-bar-title {
    font-size: 16px;
    font-weight: 700;
    color: white;
    display: flex;
    align-items: center;
    gap: 8px;
}

.filter-dropdown {
    padding: 8px 12px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 8px;
    background-color: rgba(255, 255, 255, 0.9);
    font-size: 14px;
    color: #2d3748;
    cursor: pointer;
    transition: all 0.3s ease;
    min-width: 200px;
}

.filter-dropdown:hover {
    border-color: white;
    background-color: white;
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.filter-dropdown:focus {
    outline: none;
    border-color: white;
    box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3);
}

.clear-filters-btn {
    background: rgba(255, 255, 255, 0.2);
    color: white;
    padding: 8px 16px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.clear-filters-btn:hover {
    background: rgba(255, 255, 255, 0.3);
    border-color: white;
    transform: translateY(-1px);
}

.active-filters-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
}

.active-filters-label {
    color: white;
    font-size: 14px;
    font-weight: 600;
    opacity: 0.9;
}

.filter-tag {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background: rgba(255, 255, 255, 0.95);
    color: #2d3748;
    padding: 6px 12px;
    border-radius: 20px;
    font-size: 13px;
    font-weight: 600;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    transition: all 0.2s ease;
}

.filter-tag:hover {
    background: white;
    transform: translateY(-1px);
    box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
}

.filter-tag-remove {
    cursor: pointer;
    color: #e53e3e;
    font-weight: bold;
    font-size: 16px;
    line-height: 1;
    transition: color 0.2s ease;
}

.filter-tag-remove:hover {
    color: #c53030;
}

.filter-match-counter {
    color: white;
    font-size: 14px;
    font-weight: 600;
    background: rgba(255, 255, 255, 0.2);
    padding: 6px 12px;
    border-radius: 20px;
    backdrop-filter: blur(10px);
}

/* ====== GREEN HIGHLIGHTING FOR FILTERED HORSES ====== */
.horse-row-match {
    background: linear-gradient(90deg, rgba(72, 187, 120, 0.3), rgba(72, 187, 120, 0.15)) !important;
    border-left: 4px solid #48bb78 !important;
    box-shadow: 0 2px 8px rgba(72, 187, 120, 0.3) !important;
}

table tr.horse-row-match {
    background: linear-gradient(90deg, rgba(72, 187, 120, 0.25), rgba(72, 187, 120, 0.1)) !important;
    border-left: 4px solid #48bb78;
}

table tr.horse-row-match td {
    font-weight: 600;
}

/* Optional: Add a checkmark icon to matching rows */
table tr.horse-row-match td:first-child::before {
    content: 'âœ“ ';
    color: #48bb78;
    font-weight: bold;
    margin-right: 5px;
}
    </style>
    <title>Partington Probability Engine PTY LTD</title>
</head>
<body>
    <h1>Partington Probability Engine PTY LTD</h1>

    <!-- First row: File upload and track condition -->
    <div class="input-row">
        <label for="fileInput">Upload CSV File:</label>
        <input type="file" id="fileInput" accept=".csv" multiple required>
        
        <div id="trackConditions">
            <!-- Dynamic track condition selectors will be added here -->
        </div>
    </div>

    <!-- Second row: Toggle and controls -->
    <div class="input-row-2">
        <div class="toggle-container">
            <label class="toggle-switch">
                <input type="checkbox" id="advancedToggle">
                <span class="slider"></span>
            </label>
            <label for="advancedToggle" class="toggle-label">Advanced Mode</label>
        </div>

        <button id="analyzeButton">Analyze</button>
        
        <label for="troubleshootingToggle">
            <input type="checkbox" id="troubleshootingToggle"> Enable Troubleshooting Mode
        </label>
    </div>

    <div id="results"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

<script>
// Global state management
let meetings = [];
let activeMeetingIndex = 0;
let maxTabs = 10;

// Meeting Tab Management
function createMeeting(fileName) {
    if (meetings.length >= maxTabs) {
        alert(`Maximum of ${maxTabs} meetings can be open at once. Please close a meeting first.`);
        return null;
    }
    
    const meeting = {
        id: Date.now(),
        fileName: fileName,
        races: [],
        analysisResults: []
    };
    
    meetings.push(meeting);
    activeMeetingIndex = meetings.length - 1;
    renderMeetingTabs();
    return meeting;
}

function closeMeeting(index) {
    if (confirm(`Close ${meetings[index].fileName}?`)) {
        meetings.splice(index, 1);
        if (activeMeetingIndex >= meetings.length) {
            activeMeetingIndex = Math.max(0, meetings.length - 1);
        }
        renderMeetingTabs();
        renderResults();
    }
}

function switchMeeting(index) {
    activeMeetingIndex = index;
    renderMeetingTabs();
    renderResults();
}

function renderMeetingTabs() {
    let tabsContainer = document.getElementById('meeting-tabs-container');
    
    if (!tabsContainer) {
        tabsContainer = document.createElement('div');
        tabsContainer.id = 'meeting-tabs-container';
        tabsContainer.className = 'meeting-tabs-container';
        document.body.insertBefore(tabsContainer, document.getElementById('results'));
    }
    
    if (meetings.length === 0) {
        tabsContainer.style.display = 'none';
        return;
    }
    
    tabsContainer.style.display = 'block';
    tabsContainer.innerHTML = '<div class="meeting-tabs"></div>';
    const tabsDiv = tabsContainer.querySelector('.meeting-tabs');
    
    meetings.forEach((meeting, index) => {
        const tab = document.createElement('div');
        tab.className = 'meeting-tab' + (index === activeMeetingIndex ? ' active' : '');
        
        const tabName = document.createElement('span');
        tabName.textContent = meeting.fileName;
        
        const closeBtn = document.createElement('button');
        closeBtn.className = 'tab-close';
        closeBtn.innerHTML = 'âœ•';
        closeBtn.onclick = (e) => {
            e.stopPropagation();
            closeMeeting(index);
        };
        
        tab.appendChild(tabName);
        tab.appendChild(closeBtn);
        tab.onclick = () => switchMeeting(index);
        
        tabsDiv.appendChild(tab);
    });
}


// ====== RACE NAVIGATION & ACTION FUNCTIONS ======
function createRaceNavigation(races) {
    const navContainer = document.createElement('div');
    navContainer.className = 'race-nav-container';
    navContainer.id = 'race-nav-container';

    const navButtons = document.createElement('div');
    navButtons.className = 'race-nav-buttons';

    const uniqueRaces = [...new Set(races.map(r => r['race number']))].sort((a, b) => a - b);

    uniqueRaces.forEach(raceNum => {
        const btn = document.createElement('button');
        btn.className = 'race-nav-button';
        btn.textContent = `Race ${raceNum}`;
        btn.onclick = () => scrollToRace(raceNum);
        navButtons.appendChild(btn);
    });

    navContainer.appendChild(navButtons);

    // Action buttons
    const actionDiv = document.createElement('div');
    actionDiv.className = 'action-buttons';

    const clearBtn = document.createElement('button');
    clearBtn.className = 'action-button';
    clearBtn.textContent = 'Clear All';
    clearBtn.onclick = clearAllResults;

    const expandBtn = document.createElement('button');
    expandBtn.className = 'action-button';
    expandBtn.textContent = 'Expand All';
    expandBtn.onclick = () => toggleAllRaces(true);

    const collapseBtn = document.createElement('button');
    collapseBtn.className = 'action-button';
    collapseBtn.textContent = 'Collapse All';
    collapseBtn.onclick = () => toggleAllRaces(false);

    actionDiv.appendChild(clearBtn);
    actionDiv.appendChild(expandBtn);
    actionDiv.appendChild(collapseBtn);

    navContainer.appendChild(actionDiv);

    return navContainer;
}

// ====== RACE NAVIGATION ACTION FUNCTIONS ======
function scrollToRace(raceNum) {
    const target = document.getElementById(`race-${raceNum}`);
    if (target) {
        target.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
}

function toggleAllRaces(expand = true) {
    document.querySelectorAll('.race-table-container').forEach(div => {
        if (expand) {
            div.classList.add('expanded');
            div.classList.remove('collapsed');
        } else {
            div.classList.add('collapsed');
            div.classList.remove('expanded');
        }
    });

    // Toggle the arrow icons if present
    document.querySelectorAll('.collapse-arrow').forEach(arrow => {
        if (expand) arrow.classList.remove('collapsed');
        else arrow.classList.add('collapsed');
    });
}


function clearAllResults() {
    if (meetings.length === 0) return;
    
    if (confirm('Clear all results? This cannot be undone.')) {
        meetings = [];
        activeMeetingIndex = 0;
        renderMeetingTabs();
        document.getElementById('results').innerHTML = '';
    }
}

// ====== FILTER SYSTEM FUNCTIONS ======

// Master list of all available filter criteria
const FILTER_CRITERIA = {
    droppingInClass: {
        label: 'Dropping in Class',
        detect: (notes) => notes.includes('Stepping DOWN') || notes.includes('COMBO BONUS')
    },
    risingInClass: {
        label: 'Rising in Class',
        detect: (notes) => notes.includes('Stepping UP')
    },
    fastestSectionalAvg: {
        label: 'Fastest Sectional (Avg Last 3)',
        detect: (notes) => notes.includes('fastest avg sectional')
    },
    secondFastestSectionalAvg: {
        label: '2nd Fastest Sectional (Avg Last 3)',
        detect: (notes) => notes.includes('2nd fastest avg sectional')
    },
    thirdFastestSectionalAvg: {
        label: '3rd Fastest Sectional (Avg Last 3)',
        detect: (notes) => notes.includes('3rd fastest avg sectional')
    },
    fastestLastStart: {
        label: 'Fastest Last Start Sectional',
        detect: (notes) => notes.includes('fastest last start sectional')
    },
    secondFastestLastStart: {
        label: '2nd Fastest Last Start Sectional',
        detect: (notes) => notes.includes('2nd fastest last start sectional')
    },
    thirdFastestLastStart: {
        label: '3rd Fastest Last Start Sectional',
        detect: (notes) => notes.includes('3rd fastest last start sectional')
    },
    comboBonus: {
        label: 'Combo Bonus (Sectional + Dropping Class)',
        detect: (notes) => notes.includes('COMBO BONUS')
    },
    wonLastStart: {
        label: 'Won Last Start',
        detect: (notes) => notes.includes('Dominant last start win') || notes.includes('Comfortable last start win') || notes.includes('Narrow last start win') || notes.includes('Photo finish last start win')
    },
    narrowLoss: {
        label: 'Narrow Loss (2nd/3rd)',
        detect: (notes) => notes.includes('Narrow loss') || notes.includes('very competitive')
    },
    closeLoss: {
        label: 'Close Loss (2nd/3rd)',
        detect: (notes) => notes.includes('Close loss')
    },
    ranPlaces: {
        label: 'Ran Places in Last 10',
        detect: (notes) => notes.includes('Ran places:')
    },
    recentWinner: {
        label: 'Recent Winner (Last 10)',
        detect: (notes) => notes.includes('wins in last 10')
    },
    freshAndReady: {
        label: 'Fresh and Ready (0-21 days)',
        detect: (notes) => notes.includes('Fresh and ready')
    },
    quickBackup: {
        label: 'Quick Back-up (< 14 days)',
        detect: (notes) => notes.includes('Quick back-up')
    },
    idealSpacing: {
        label: 'Ideal Spacing (21-60 days)',
        detect: (notes) => notes.includes('Ideal spacing')
    },
    undefeatedDistance: {
        label: 'Undefeated at Distance',
        detect: (notes) => notes.includes('UNDEFEATED') && notes.includes('at this distance')
    },
    undefeatedTrack: {
        label: 'Undefeated at Track',
        detect: (notes) => notes.includes('UNDEFEATED') && notes.includes('at this track')
    },
    exceptionalWinRate: {
        label: 'Exceptional Win Rate',
        detect: (notes) => notes.includes('Exceptional win rate')
    },
    strongWinRate: {
        label: 'Strong Win Rate',
        detect: (notes) => notes.includes('Strong win rate')
    },
    goodWinRate: {
        label: 'Good Win Rate',
        detect: (notes) => notes.includes('Good win rate')
    },
    elitePodiumRate: {
        label: 'Elite Podium Rate',
        detect: (notes) => notes.includes('Elite podium rate')
    },
    excellentPodiumRate: {
        label: 'Excellent Podium Rate',
        detect: (notes) => notes.includes('Excellent podium rate')
    },
    strongPodiumRate: {
        label: 'Strong Podium Rate',
        detect: (notes) => notes.includes('Strong podium rate')
    },
    goodPodiumRate: {
        label: 'Good Podium Rate',
        detect: (notes) => notes.includes('Good podium rate')
    },
    optimalWeight: {
        label: 'Optimal Weight (52-56kg)',
        detect: (notes) => notes.includes('Optimal weight')
    },
    goodWeight: {
        label: 'Good Weight Range',
        detect: (notes) => /Weight less claim = 5[2-6]kg/.test(notes)
    },
    loveTheJockey: {
        label: 'Elite Jockey (Love the Jockey)',
        detect: (notes) => notes.includes('Love the Jockey')
    },
    topJockey: {
        label: 'Top Jockey',
        detect: (notes) => notes.includes('Good Jockey')
    },
    loveTheTrainer: {
        label: 'Elite Trainer (Love the Trainer)',
        detect: (notes) => notes.includes('Love the Trainer')
    },
    topTrainer: {
        label: 'Top Trainer',
        detect: (notes) => notes.includes('Good Trainer')
    },
    firstUpSpecialist: {
        label: 'First Up Specialist',
        detect: (notes) => notes.includes('first-up specialist')
    },
    secondUpSpecialist: {
        label: 'Second Up Specialist',
        detect: (notes) => notes.includes('second-up specialist')
    },
    longerDistance: {
        label: 'Longer Distance Than Previous',
        detect: (notes) => notes.includes('Longer dist than previous')
    },
    shorterDistance: {
        label: 'Shorter Distance Than Previous',
        detect: (notes) => notes.includes('Shorter dist than previous')
    },
    sameDistance: {
        label: 'Same Distance as Previous',
        detect: (notes) => notes.includes('Same dist as previous')
    },
    positiveFormPrice: {
        label: 'Positive Form Price',
        detect: (notes) => /\+\d+\.\d+ : Form price/.test(notes)
    },
    goodBarrier: {
        label: 'Good Barrier (1-4)',
        detect: (notes) => notes.includes('Excellent barrier') || notes.includes('Good barrier')
    }
};

// Parse a horse's notes and return which criteria they meet
function parseHorseCriteria(notes) {
    if (!notes || typeof notes !== 'string') {
        return {};
    }
    
    const criteria = {};
    
    // Check each filter criterion
    Object.keys(FILTER_CRITERIA).forEach(key => {
        criteria[key] = FILTER_CRITERIA[key].detect(notes);
    });
    
    return criteria;
}

// Global state for active filters
let activeFilters = [];

// Create the filter bar UI
function createFilterBar() {
    const filterBar = document.createElement('div');
    filterBar.className = 'filter-bar-container';
    filterBar.id = 'filter-bar';

    // Header section with dropdown and clear button
    const headerDiv = document.createElement('div');
    headerDiv.className = 'filter-bar-header';

    // Title with icon
    const title = document.createElement('div');
    title.className = 'filter-bar-title';
    title.innerHTML = 'ðŸ” Add Filter:';

    // Dropdown selector
    const dropdown = document.createElement('select');
    dropdown.className = 'filter-dropdown';
    dropdown.id = 'filter-dropdown';

    // Default option
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = 'Select a filter...';
    dropdown.appendChild(defaultOption);

    // Add all filter options
    Object.keys(FILTER_CRITERIA).forEach(key => {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = FILTER_CRITERIA[key].label;
        dropdown.appendChild(option);
    });

    // Clear all filters button
    const clearBtn = document.createElement('button');
    clearBtn.className = 'clear-filters-btn';
    clearBtn.textContent = 'Clear All Filters';
    clearBtn.onclick = clearAllFilters;

    headerDiv.appendChild(title);
    headerDiv.appendChild(dropdown);
    headerDiv.appendChild(clearBtn);
    filterBar.appendChild(headerDiv);

    // Active filters display section
    const activeFiltersDiv = document.createElement('div');
    activeFiltersDiv.className = 'active-filters-container';
    activeFiltersDiv.id = 'active-filters-container';
    filterBar.appendChild(activeFiltersDiv);

    // Event listener for dropdown selection
    dropdown.addEventListener('change', function() {
        if (this.value) {
            addFilter(this.value);
            this.value = ''; // Reset dropdown
        }
    });

    return filterBar;
}

// Update the active filters display
function updateActiveFiltersDisplay() {
    const container = document.getElementById('active-filters-container');
    if (!container) return;

    container.innerHTML = '';

    if (activeFilters.length === 0) {
        return; // Don't show anything if no filters
    }

    // "Active Filters:" label
    const label = document.createElement('span');
    label.className = 'active-filters-label';
    label.textContent = 'Active Filters:';
    container.appendChild(label);

    // Create a tag for each active filter
    activeFilters.forEach(filterKey => {
        const tag = document.createElement('div');
        tag.className = 'filter-tag';

        const tagText = document.createElement('span');
        tagText.textContent = FILTER_CRITERIA[filterKey].label;

        const removeBtn = document.createElement('span');
        removeBtn.className = 'filter-tag-remove';
        removeBtn.textContent = 'Ã—';
        removeBtn.onclick = () => removeFilter(filterKey);

        tag.appendChild(tagText);
        tag.appendChild(removeBtn);
        container.appendChild(tag);
    });

    // Match counter
    const matchCounter = document.createElement('span');
    matchCounter.className = 'filter-match-counter';
    matchCounter.id = 'filter-match-counter';
    matchCounter.textContent = 'Calculating matches...';
    container.appendChild(matchCounter);

    // Update the counter after a brief delay to let DOM update
    setTimeout(updateMatchCounter, 100);
}

// Update the match counter
function updateMatchCounter() {
    const counter = document.getElementById('filter-match-counter');
    if (!counter) return;

    // Count matching horses
    const matchingRows = document.querySelectorAll('.horse-row-match');
    const matchCount = matchingRows.length;

    // Count races with matches
    const racesWithMatches = new Set();
    matchingRows.forEach(row => {
        // Find which race this row belongs to
        const raceContainer = row.closest('.race-container');
        if (raceContainer) {
            racesWithMatches.add(raceContainer.id);
        }
    });

    if (activeFilters.length === 0) {
        counter.textContent = 'No filters active';
    } else if (matchCount === 0) {
        counter.textContent = 'No horses match all filters';
    } else if (matchCount === 1) {
        counter.textContent = `1 horse matches in ${racesWithMatches.size} race${racesWithMatches.size !== 1 ? 's' : ''}`;
    } else {
        counter.textContent = `${matchCount} horses match across ${racesWithMatches.size} race${racesWithMatches.size !== 1 ? 's' : ''}`;
    }
}

// Add a filter to the active filters list
function addFilter(filterKey) {
    // Don't add if already active
    if (activeFilters.includes(filterKey)) {
        return;
    }

    // Add to active filters
    activeFilters.push(filterKey);

    // Update the display
    updateActiveFiltersDisplay();

    // Apply filters to highlight horses
    applyFilters();
}

// Remove a filter from the active filters list
function removeFilter(filterKey) {
    // Remove from active filters
    activeFilters = activeFilters.filter(key => key !== filterKey);

    // Update the display
    updateActiveFiltersDisplay();

    // Re-apply filters (or clear highlights if no filters)
    applyFilters();
}

// Clear all filters
function clearAllFilters() {
    // Clear the active filters array
    activeFilters = [];

    // Update the display
    updateActiveFiltersDisplay();

    // Remove all highlighting
    applyFilters();
}

// Apply filters and highlight matching horses
function applyFilters() {
    // Get all horse rows from all race tables
    const allRows = document.querySelectorAll('table tr');

    // If no filters are active, remove all highlighting
    if (activeFilters.length === 0) {
        allRows.forEach(row => {
            row.classList.remove('horse-row-match');
        });
        return;
    }

    // Loop through each row
    allRows.forEach(row => {
        // Skip header rows (they don't have horse data)
        const cells = row.querySelectorAll('td');
        if (cells.length === 0) return;

        // Get the notes cell (last cell in the row)
        const notesCell = cells[cells.length - 1];
        if (!notesCell) return;

        const notes = notesCell.innerText || notesCell.textContent;

        // Parse what criteria this horse meets
        const horseCriteria = parseHorseCriteria(notes);

        // Check if horse meets ALL active filters (AND logic)
        const meetsAllFilters = activeFilters.every(filterKey => {
            return horseCriteria[filterKey] === true;
        });

        // Apply or remove highlighting
        if (meetsAllFilters) {
            row.classList.add('horse-row-match');
        } else {
            row.classList.remove('horse-row-match');
        }
    });

    // Update the match counter
    updateMatchCounter();
}

// Add event listener for file input changes
document.getElementById('fileInput').addEventListener('change', function() {
    const files = this.files;
    const trackConditionsDiv = document.getElementById('trackConditions');
    
    // Clear existing dropdowns
    trackConditionsDiv.innerHTML = '';
    
    // Create dropdown for each selected file
    for (let i = 0; i < files.length; i++) {
        const fileName = files[i].name.replace('.csv', '');
        
        const container = document.createElement('div');
        container.style.cssText = 'display: flex; align-items: center; gap: 10px; margin-bottom: 10px;';
        
        const label = document.createElement('label');
        label.textContent = `${fileName} track condition:`;
        label.style.cssText = 'font-size: 14px; font-weight: 600; color: #4a5568; min-width: 200px;';
        
        const select = document.createElement('select');
        select.id = `trackCondition_${i}`;
        select.style.cssText = 'padding: 8px 12px; border: 2px solid #e9ecef; border-radius: 8px; background-color: #f5f7fa; font-size: 14px; color: #4a5568;';
        
        // Add options
        const options = ['firm', 'good', 'soft', 'heavy', 'synthetic'];
        options.forEach(option => {
            const optionElement = document.createElement('option');
            optionElement.value = option;
            optionElement.textContent = option.charAt(0).toUpperCase() + option.slice(1);
            select.appendChild(optionElement);
        });
        
        container.appendChild(label);
        container.appendChild(select);
        trackConditionsDiv.appendChild(container);
    }
});

// Add event listener for analyze button
document.getElementById('analyzeButton').addEventListener('click', function() {
    const fileInput = document.getElementById('fileInput');
    const files = fileInput.files;
    
    // Capture track conditions for each file
    const trackConditions = [];
    for (let i = 0; i < files.length; i++) {
        const dropdown = document.getElementById(`trackCondition_${i}`);
        if (dropdown) {
            trackConditions.push(dropdown.value);
        } else {
            trackConditions.push('good'); // default fallback
        }
    }
    
    const isAdvanced = document.getElementById('advancedToggle').checked;
    const troubleshooting = document.getElementById('troubleshootingToggle').checked;

    if (files.length > 0) {
        let allData = [];
        let filesProcessed = 0;
        
        for (let i = 0; i < files.length; i++) {
            const fileName = files[i].name;
            const trackCondition = trackConditions[i];
            
            Papa.parse(files[i], {
                delimiter: ",",
                header: true,
                complete: function(results) {
                    const data = results.data;
                    const analysisResults = [];

                    // Get the header row for comparison
                    const headerRow = results.meta.fields;

                    // Filter out rows that have any undefined values or are repeats of the header row
                    var filteredData = data.filter(row => {
                        const isHeaderRow = Object.values(row).every((value, index) => value === headerRow[index]);
                        return !isHeaderRow;
                    });

                    // Calculate score for horses using (1) multi-row analysis and (2) single row analysis
                    const filteredDataSectional = getLowestSectionalsByRace(filteredData);
                    const averageFormPrices = calculateAverageFormPrices(filteredData);

                    // Make filteredData only the latest entry for each horse
                    const getUniqueHorsesOnly = (data) => {
                        const latestByComposite = new Map();
                        
                        data.forEach(entry => {
                            const compositeKey = `${entry['horse name']}-${entry['race number']}`;
                            const currentDate = entry['form meeting date'];
                            
                            if (!latestByComposite.has(compositeKey) || 
                                currentDate > new Date(latestByComposite.get(compositeKey)['form meeting date'])) {
                                latestByComposite.set(compositeKey, entry);
                            }
                        });
                        
                        return Array.from(latestByComposite.values());
                    };

                    filteredData = getUniqueHorsesOnly(filteredData);

                    // Process each horse entry
                    filteredData.forEach((horse, index) => {
                        if (horse['meeting date'] === undefined || !horse['horse name']) return;
                        
                        const compositeKey = `${horse['horse name']}-${horse['race number']}`;
                        const avgFormPrice = averageFormPrices[compositeKey];

                        var [score, notes] = calculateScore(horse, trackCondition, troubleshooting, avgFormPrice);

                        const raceNumber = horse['race number'];
                        const horseName = horse['horse name'];

                        const matchingHorse = filteredDataSectional.find(horse => 
                            parseInt(horse.race) === parseInt(raceNumber) && 
                            horse.name.toLowerCase().trim() === horseName.toLowerCase().trim()
                        );

                        if (matchingHorse) {
                            score += matchingHorse.sectionalScore;
                            notes += matchingHorse.sectionalNote;
                            
                            if (matchingHorse.hasAverage1st && matchingHorse.hasLastStart1st) {
                                const [classScore, classNotes] = compareClasses(
                                    horse['class restrictions'], 
                                    horse['form class'],
                                    horse['race prizemoney'],
                                    horse['prizemoney']
                                );
                                if (classScore > 0) {
                                    score += 15;
                                    notes += '+15.0 : COMBO BONUS - Fastest sectional + dropping in class\n';
                                    
                                    if (troubleshooting) {
                                        console.log(`Combo bonus awarded to ${horseName}: Fastest sectional + dropping in class (class score: ${classScore})`);
                                    }
                                }
                            }
                        } else {
                            console.log(`No matching horse found for ${horseName} in race ${raceNumber}`);
                        }

                        analysisResults.push({ horse, score, notes });
                    });

                    var uniqueResults = Array.from(new Map(analysisResults.map(item => [item.horse['horse name'], item])).values());
                    uniqueResults = calculateTrueOdds(uniqueResults, priorStrength=1, troubleshooting);
                    uniqueResults.sort((a,b)=> (a.horse['race number'] - b.horse['race number'] || b.score - a.score));

                    // Create or get meeting
                    let currentMeeting = createMeeting(fileName);
                    if (!currentMeeting) return;

                    currentMeeting.races = filteredData;
                    currentMeeting.analysisResults = uniqueResults;

                    // Render results for active meeting
                    renderResults();
                }
            });
        }
    } else {
        alert('Please upload a CSV file.');
    }
});

// ====== FINAL RENDER RESULTS WRAPPER (preserves scores + enables controls) ======
function renderResults() {
    const resultsDiv = document.getElementById('results');
    resultsDiv.innerHTML = '';

    if (meetings.length === 0) {
        resultsDiv.innerHTML = '<p>No meetings loaded.</p>';
        return;
    }

    const activeMeeting = meetings[activeMeetingIndex];
    if (!activeMeeting || !activeMeeting.analysisResults) {
        resultsDiv.innerHTML = '<p>No analysis results available.</p>';
        return;
    }

    // Step 1 â€” Render all results normally (so we keep your full scoring view)
    displayResults(activeMeeting.analysisResults, false, activeMeeting.fileName);

    // Step 2 â€” Inject the navigation panel above
    const navBar = createRaceNavigation(activeMeeting.races);
    resultsDiv.prepend(navBar);

    // Step 2.5 â€” Inject the filter bar between navigation and races
    const filterBar = createFilterBar();
    navBar.insertAdjacentElement('afterend', filterBar);

    // Re-apply any active filters to the newly rendered results
    if (activeFilters.length > 0) {
        applyFilters();
    }

    // Step 4 â€” Re-bind Expand / Collapse All buttons (from your new UI)
    const expandAllBtn = document.getElementById('expandAll');
    const collapseAllBtn = document.getElementById('collapseAll');
    if (expandAllBtn) {
        expandAllBtn.onclick = () => {
            document.querySelectorAll('.race-table-container').forEach(div => {
                div.classList.add('expanded');
                div.classList.remove('collapsed');
            });
        };
    }

    if (collapseAllBtn) {
        collapseAllBtn.onclick = () => {
            document.querySelectorAll('.race-table-container').forEach(div => {
                div.classList.add('collapsed');
                div.classList.remove('expanded');
            });
        };
    }

    // Step 5 â€” Re-bind race navigation scroll buttons
    document.querySelectorAll('.race-nav-btn').forEach(btn => {
        btn.onclick = () => {
            const target = document.getElementById(`race-${btn.dataset.race}`);
            if (target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
        };
    });
}





// Mapping of equivalent jockey names
const jockeyMapping = {
    "J B Mc Donald": "James McDonald",
    "A Bullock": "Aaron Bullock",
    "W Pike": "William Pike",
    "N Rawiller": "Nash Rawiller",
    "J Part": "Josh Parr",
    "J R Collett": "Jason Collett",
    "M Zahra": "Mark Zahra",
    "B Shinn": "Blake Shinn",
    "C Williams": "Craig Williams",
    "E Brown": "Ethan Brown",
    "D Lane": "Damian Lane",
    "B Melham": "Ben Melham",
    //"J Kah": "" ???
    // Add more mappings as needed
};


// Mapping of equivalent trainer names
const trainerMapping = {
    'C Maher': 'Ciaron Maher',
    'C J Waller': 'Chris Waller',
    'Ben Will & Jd Hayes': 'Ben, Will & J.D. Hayes',
    'G Waterhouse & A Bott': 'Gai Waterhouse & Adrian Bott',
    'G M Begg': 'Grahame Begg',
    'P Stokes': 'Phillip Stokes',
    'M M Laurie': 'Matthew Laurie'
};

   
function convertCSV(data) {
    // Normalize line endings (convert CRLF and CR to LF)
    data = data.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

    // Replace semicolons with commas
    data = data.replace(/;/g, ',');

    // Remove extra whitespace around fields
    data = data.replace(/^\s+|\s+$/gm, '');

    // Handle inconsistent quoting
    // Remove quotes if they are not needed
    data = data.replace(/(^"|"$)/g, ''); // Remove quotes at the start/end of the line
    data = data.replace(/"([^"]*)"/g, '$1'); // Remove quotes around fields

    // Optionally, you can add more specific handling for quoted fields
    // For example, if a field contains a comma, it should be quoted
    data = data.replace(/([^,]+),([^,]+)/g, '"$1,$2"');

    return data;
}
function calculateScore(horseRow, trackCondition, troubleshooting = false, averageFormPrice) {
    if (troubleshooting) console.log(`Calculating score for horse: ${horseRow['horse name']}`);

    var score = 0;
    var notes = '';

    // Check horse weight  and score
    var [a, b] = checkWeight(horseRow['horse weight'], horseRow['horse claim']);
    score += a;
    notes += b;

    // Check horse places in last 10 runs
    if (troubleshooting) console.log(`Calculating last 10: ${horseRow['horse last10']}`);
    [a, b] = checkLast10runs(horseRow['horse last10']);
    score += a;
    notes += b;

    // Check if horse jockey is someone we like or not
    [a, b] = checkJockeys(horseRow['horse jockey']);
    score += a;
    notes += b;

    // Check if horse trainer  is someone we like or not
    [a, b] = checkTrainers(horseRow['horse trainer']);
    score += a;
    notes += b;

   // Check if horse has won at this track (ENHANCED WEIGHTED SYSTEM)
    [a, b] = checkTrackForm(horseRow['horse record track']);
    score += a;
    notes += b;

   // Check if horse has won at this track+distance combo (ENHANCED WEIGHTED SYSTEM)
    [a, b] = checkTrackDistanceForm(horseRow['horse record track distance']);
    score += a;
    notes += b;

    // Check if horse has won at this distance (ENHANCED WEIGHTED SYSTEM)
    [a, b] = checkDistanceForm(horseRow['horse record distance']);
    score += a;
    notes += b;

    // Check if the last race the horse ran was longer, same or shorter distance
    [a, b] = checkLastDistance(horseRow);
    score += a;
    notes += b;
    
   // Check horse form on actual track condition (ENHANCED WEIGHTED SYSTEM)
    const formTrackCondition = 'horse record ' + trackCondition;
    [a, b] = checkTrackConditionForm(horseRow[formTrackCondition], trackCondition);
    score += a;
    notes += b;
    

   // Check horse current and former classes
var [a, b] = compareClasses(
    horseRow['class restrictions'], 
    horseRow['form class'],
    horseRow['race prizemoney'],
    horseRow['prizemoney']
);
score += a;
notes += b;

// Check days since last run
[a, b] = checkDaysSinceLastRun(horseRow['meeting date'], horseRow['form meeting date']);
score += a;
notes += b;

// Check last run margin
[a, b] = checkMargin(horseRow['form position'], horseRow['form margin']);
score += a;
notes += b;

    // Check form price
[a, b] = checkFormPrice(averageFormPrice);
score += a;
notes += b;

// Check first up / second up specialist
[a, b] = checkFirstUpSecondUp(horseRow);
score += a;
notes += b;

return [score, notes]; // Return the score based on the first letter
}


function checkWeight(weight, claim) {
    let addScore = 0;
    let note = '';

    const act_weight = weight;
    if (act_weight > 65) {
        addScore += 0;
        note += 'ERR : weight less claim, above 65kg\n';
    } else if (act_weight < 49) {
        addScore += 0;
        note += 'ERR : Weight less claim, below 49kg\n';
    } else if (act_weight >= 49 && act_weight <=65) {
        addScore += (65.0 - act_weight) * 2;
        note += '+ ' +  addScore + ' : Weight less claim = ' + act_weight + 'kg\n';
    } else {
        addScore += 0;
        note += 'ERR : Weight invalid\n';
    }
    return [addScore, note]; // Return the score from this function
}

function checkLast10runs(last10) {
    last10 = String(last10).trim();
    
    if (last10.length > 99) {
        throw new Error("String must be 99 characters or less.");
    }

    let addScore = 0;
    let count = 0;
    let note2 = '';
    let note = '';
    let hasWin = last10.includes('1');

    for (let i = last10.length - 1; i >= 0; i--) {
        let char = last10[i];
        if (char != 'X' && char != 'x' && count < 5) {
            count++;
            if (char === '1') {
                addScore += 10;
                note2 += ' 1st';
            }
            if (char === '2') {
                addScore += 5;
                note2 += ' 2nd';
            }
            if (char === '3') {
                addScore += 2;
                note2 += ' 3rd';
            }
        }    
    }

    // FORMAT THE NOTE *BEFORE* APPLYING THE NO-WINS PENALTY
    if (addScore > 0) {
        note = '+' + addScore + '.0 : Ran places:' + note2 + '\n';
    }

    // NOW APPLY THE NO-WINS PENALTY
    if (!hasWin && last10.length > 0) {
        addScore -= 15;
        note += '-15.0 : No wins in last 10 starts - non-winner\n';
    }
    
    // Handle the case where we had places but ended negative
    if (addScore < 0 && note2) {
        // Note already formatted above, just return
    }
     
    return [addScore, note];
}

function normalizeJockeyName(jockeyName) {
    // Function used by checkJockeys to substitute known variations with standard names
    // I should probably merge this with normalizeClassName....
    for (const [key, value] of Object.entries(jockeyMapping)) {
        if (jockeyName.startsWith(key)) {
            return jockeyName.replace(key, value);
        }
    }
    return jockeyName; // Return the original if no mapping is found
}
function checkJockeys(JockeyName) {
    // Function for checking jockey name against lists
    var addScore = 0;
    var note = '';

    // Check for known spelling/name changes
    JockeyName = normalizeJockeyName(JockeyName)

    const tenPointJockeys = [
        'Blake Shinn',
        'James McDonald',
        'Jason Collett',
        'Mark Zahra',
        'Craig Williams',
        'Nash Rawiller',
        'Tim Clark'
    ]
    const fivePointJockeys = [
        'Aaron Bullock',
        'Damian Lane',
        'Ethan Brown',
        'Ben Melham',
        'Jamie Melham',
        'Josh Parr',
        'William Pike',
        'Zac Lloyd',
        'J Kah'
    ]
    const negativeJockeys = [
        'Kerrin McEvoy'
    ]

    if (tenPointJockeys.includes(JockeyName)) {
        addScore += 10;
        note += '+10.0 : Love the Jockey\n';
    }
    if (fivePointJockeys.includes(JockeyName)) {
        addScore += 5;
        note += '+ 5.0 : Like the Jockey\n';
    }
    if (negativeJockeys.includes(JockeyName)) {
        addScore -= 5;
        note += '- 5.0 : Kerrin Useless McEvoy\n';
    }
    return [addScore, note];
}

function normalizeTrainerName(trainerName) {
    // Function used by checkJockeys to substitute known variations with standard names
    // I should probably merge this with normalizeClassName....
    for (const [key, value] of Object.entries(trainerMapping)) {
        if (trainerName.startsWith(key)) {
            return trainerName.replace(key, value);
        }
    }
    return trainerName; // Return the original if no mapping is found
}

function checkTrainers(trainerName) {
    // Function for checking jockey name against lists
    var addScore = 0;
    var note = '';

    // Check for known spelling/name changes
    trainerName = normalizeTrainerName(trainerName)

   const fivePointTrainers = [
    'Ciaron Maher',
    'Chris Waller',
    'Ben, Will & J.D. Hayes',
    'Annabel & Rob Archibald',
    'Bjorn Baker',
    'Gai Waterhouse & Adrian Bott',
    'Grahame Begg',
    'Matthew Laurie',
    'Phillip Stokes'
]
   
    if (fivePointTrainers.includes(trainerName)) {
        addScore += 5;
        note += '+ 5.0 : Like the Trainer\n';
    }
   
    return [addScore, note];
}

function checkRacingForm(racingForm, runType) {
    // Check if horse has won, or got 5th or better twice, in the past 3 runs at this distance
    let addScore = 0; // Initialize score
    var note = '';
    // Ensure each item is a string before processing
    if (typeof racingForm !== 'string') {
        const err = typeof racingForm
        note += 'Racing form ${runType} not string. Received type: ' + err;
        return [addScore, note];
    }
    // Split the string by '-' and convert to numbers
    const numbers = racingForm.split(/[:\-]/).map(s => Number(s.trim()));
    
    if (numbers.length != 4) {
        note += 'Racing form not correct format. Received: ' + racingForm;
        return [addScore, note];
    }
     
    // Check number of podiums is equal or less than races
    if ((numbers[1] + numbers[2] + numbers[3]) > numbers[0]) {
        note += 'More podiums than runs?? Received: ' + racingForm;
        return [addScore, note];
    }
    
    // Check if horse has any wins
    if (numbers[1] > 0) {
        addScore += 5; // Add 5 points if any number is '1'
        note += '+ 5.0 : Had at least 1 win at ' + runType + '\n';
    }
    
    // SEPARATELY check for podium rate (can award points in addition to win bonus)
    const count = (numbers[1] + numbers[2] + numbers[3]) / numbers[0];
    if (count >= 0.5) {
        addScore += 5; // Add 5 points if more than half of runs are places or wins
        note += '+ 5.0 : Podium >=50% of runs at ' + runType + '\n';
    }
    
    return [addScore, note]; // Return the total score
}

function checkTrackConditionForm(racingForm, trackCondition) {
    let addScore = 0;
    let note = '';
    
    if (typeof racingForm !== 'string') {
        note += 'Track condition form not string. Received type: ' + typeof racingForm + '\n';
        return [addScore, note];
    }
    
    const numbers = racingForm.split(/[:\-]/).map(s => Number(s.trim()));
    
    if (numbers.length != 4) {
        note += 'Track condition form incorrect format. Received: ' + racingForm + '\n';
        return [addScore, note];
    }
    
    const runs = numbers[0];
    const wins = numbers[1];
    const seconds = numbers[2];
    const thirds = numbers[3];
    const podiums = wins + seconds + thirds;
    
    if (podiums > runs) {
        note += 'More podiums than runs?? Received: ' + racingForm + '\n';
        return [addScore, note];
    }
    
    if (runs === 0) {
        note += '+ 0.0 : No runs on ' + trackCondition + ' track\n';
        return [addScore, note];
    }
    
    const winRate = wins / runs;
    const podiumRate = podiums / runs;
    
    let winScore = 0;
    if (winRate >= 0.51) {
        winScore = 12;
        note += '+ 12.0 : Exceptional win rate (' + (winRate * 100).toFixed(0) + '%) on ' + trackCondition + '\n';
    } else if (winRate >= 0.36) {
        winScore = 10;
        note += '+ 10.0 : Strong win rate (' + (winRate * 100).toFixed(0) + '%) on ' + trackCondition + '\n';
    } else if (winRate >= 0.26) {
        winScore = 8;
        note += '+ 8.0 : Good win rate (' + (winRate * 100).toFixed(0) + '%) on ' + trackCondition + '\n';
    } else if (winRate >= 0.16) {
        winScore = 5;
        note += '+ 5.0 : Moderate win rate (' + (winRate * 100).toFixed(0) + '%) on ' + trackCondition + '\n';
    } else if (winRate >= 0.01) {
        winScore = 2;
        note += '+ 2.0 : Low win rate (' + (winRate * 100).toFixed(0) + '%) on ' + trackCondition + '\n';
    } else {
        winScore = 0;
        note += '+ 0.0 : No wins on ' + trackCondition + '\n';
    }
    
    let podiumScore = 0;
    if (podiumRate >= 0.85) {
        podiumScore = 12;
        note += '+ 12.0 : Elite podium rate (' + (podiumRate * 100).toFixed(0) + '%) on ' + trackCondition + '\n';
    } else if (podiumRate >= 0.70) {
        podiumScore = 10;
        note += '+ 10.0 : Excellent podium rate (' + (podiumRate * 100).toFixed(0) + '%) on ' + trackCondition + '\n';
    } else if (podiumRate >= 0.55) {
        podiumScore = 9;
        note += '+ 9.0 : Strong podium rate (' + (podiumRate * 100).toFixed(0) + '%) on ' + trackCondition + '\n';
    } else if (podiumRate >= 0.40) {
        podiumScore = 6;
        note += '+ 6.0 : Good podium rate (' + (podiumRate * 100).toFixed(0) + '%) on ' + trackCondition + '\n';
    } else if (podiumRate >= 0.25) {
        podiumScore = 3;
        note += '+ 3.0 : Moderate podium rate (' + (podiumRate * 100).toFixed(0) + '%) on ' + trackCondition + '\n';
    } else {
        podiumScore = 0;
        note += '+ 0.0 : Poor podium rate (' + (podiumRate * 100).toFixed(0) + '%) on ' + trackCondition + '\n';
    }
    
    let undefeatedBonus = 0;
    if (wins === runs && runs >= 2) {
        if (runs >= 5) {
            undefeatedBonus = 15;
            note += '+ 15.0 : UNDEFEATED in ' + runs + ' runs on ' + trackCondition + '! (5+ runs)\n';
        } else if (runs >= 4) {
            undefeatedBonus = 14;
            note += '+ 14.0 : UNDEFEATED in ' + runs + ' runs on ' + trackCondition + '! (4 runs)\n';
        } else if (runs >= 3) {
            undefeatedBonus = 12;
            note += '+ 12.0 : UNDEFEATED in ' + runs + ' runs on ' + trackCondition + '! (3 runs)\n';
        } else {
            undefeatedBonus = 8;
            note += '+ 8.0 : UNDEFEATED in ' + runs + ' runs on ' + trackCondition + '! (2 runs)\n';
        }
    }
    
    let subtotal = winScore + podiumScore + undefeatedBonus;
    
    let confidenceMultiplier = 1.0;
    let confidenceNote = '';
    
    if (trackCondition === 'good') {
        if (runs >= 16) {
            confidenceMultiplier = 1.0;
            confidenceNote = ' [High confidence: ' + runs + ' runs]';
        } else if (runs >= 11) {
            confidenceMultiplier = 0.95;
            confidenceNote = ' [Good confidence: ' + runs + ' runs]';
        } else if (runs >= 6) {
            confidenceMultiplier = 0.85;
            confidenceNote = ' [Medium confidence: ' + runs + ' runs]';
        } else {
            confidenceMultiplier = 0.7;
            confidenceNote = ' [Low confidence: ' + runs + ' runs]';
        }
    } else if (trackCondition === 'soft') {
        if (runs >= 11) {
            confidenceMultiplier = 1.0;
            confidenceNote = ' [High confidence: ' + runs + ' runs]';
        } else if (runs >= 7) {
            confidenceMultiplier = 0.95;
            confidenceNote = ' [Good confidence: ' + runs + ' runs]';
        } else if (runs >= 4) {
            confidenceMultiplier = 0.85;
            confidenceNote = ' [Medium confidence: ' + runs + ' runs]';
        } else {
            confidenceMultiplier = 0.7;
            confidenceNote = ' [Low confidence: ' + runs + ' runs]';
        }
    } else if (trackCondition === 'heavy') {
        if (runs >= 7) {
            confidenceMultiplier = 1.0;
            confidenceNote = ' [High confidence: ' + runs + ' runs]';
        } else if (runs >= 5) {
            confidenceMultiplier = 0.9;
            confidenceNote = ' [Good confidence: ' + runs + ' runs]';
        } else if (runs >= 3) {
            confidenceMultiplier = 0.8;
            confidenceNote = ' [Medium confidence: ' + runs + ' runs]';
        } else {
            confidenceMultiplier = 0.6;
            confidenceNote = ' [Low confidence: ' + runs + ' runs]';
        }
    } else if (trackCondition === 'firm') {
        if (runs >= 5) {
            confidenceMultiplier = 1.0;
            confidenceNote = ' [High confidence: ' + runs + ' runs]';
        } else if (runs >= 3) {
            confidenceMultiplier = 0.85;
            confidenceNote = ' [Medium confidence: ' + runs + ' runs]';
        } else if (runs >= 2) {
            confidenceMultiplier = 0.7;
            confidenceNote = ' [Low confidence: ' + runs + ' runs]';
        } else {
            confidenceMultiplier = 0.5;
            confidenceNote = ' [Very low confidence: ' + runs + ' run]';
        }
    } else if (trackCondition === 'synthetic') {
        if (runs >= 7) {
            confidenceMultiplier = 1.0;
            confidenceNote = ' [High confidence: ' + runs + ' runs]';
        } else if (runs >= 4) {
            confidenceMultiplier = 0.85;
            confidenceNote = ' [Medium confidence: ' + runs + ' runs]';
        } else if (runs >= 2) {
            confidenceMultiplier = 0.7;
            confidenceNote = ' [Low confidence: ' + runs + ' runs]';
        } else {
            confidenceMultiplier = 0.5;
            confidenceNote = ' [Very low confidence: ' + runs + ' run]';
        }
    }
    
    addScore = subtotal * confidenceMultiplier;
    
    if (runs >= 5 && wins === 0 && podiumRate < 0.20) {
        addScore -= 8;
        note += '- 8.0 : Poor performance on ' + trackCondition + ' (' + runs + ' runs, 0 wins, <20% podium)\n';
    }
    
    note += '= ' + addScore.toFixed(1) + ' : Total track condition score' + confidenceNote + '\n';
    
    return [addScore, note];
}

function checkDistanceForm(racingForm) {
    let addScore = 0;
    let note = '';
    
    if (typeof racingForm !== 'string') {
        note += 'Distance form not string. Received type: ' + typeof racingForm + '\n';
        return [addScore, note];
    }
    
    const numbers = racingForm.split(/[:\-]/).map(s => Number(s.trim()));
    
    if (numbers.length != 4) {
        note += 'Distance form incorrect format. Received: ' + racingForm + '\n';
        return [addScore, note];
    }
    
    const runs = numbers[0];
    const wins = numbers[1];
    const seconds = numbers[2];
    const thirds = numbers[3];
    const podiums = wins + seconds + thirds;
    
    if (podiums > runs) {
        note += 'More podiums than runs?? Received: ' + racingForm + '\n';
        return [addScore, note];
    }
    
    if (runs === 0) {
        note += '+ 0.0 : No runs at this distance\n';
        return [addScore, note];
    }
    
    const winRate = wins / runs;
    const podiumRate = podiums / runs;
    
    let winScore = 0;
    if (winRate >= 0.51) {
        winScore = 8;
        note += '+ 8.0 : Exceptional win rate (' + (winRate * 100).toFixed(0) + '%) at this distance\n';
    } else if (winRate >= 0.36) {
        winScore = 7;
        note += '+ 7.0 : Strong win rate (' + (winRate * 100).toFixed(0) + '%) at this distance\n';
    } else if (winRate >= 0.26) {
        winScore = 5;
        note += '+ 5.0 : Good win rate (' + (winRate * 100).toFixed(0) + '%) at this distance\n';
    } else if (winRate >= 0.16) {
        winScore = 3;
        note += '+ 3.0 : Moderate win rate (' + (winRate * 100).toFixed(0) + '%) at this distance\n';
    } else if (winRate >= 0.01) {
        winScore = 1;
        note += '+ 1.0 : Low win rate (' + (winRate * 100).toFixed(0) + '%) at this distance\n';
    } else {
        winScore = 0;
        note += '+ 0.0 : No wins at this distance\n';
    }
    
    let podiumScore = 0;
    if (podiumRate >= 0.85) {
        podiumScore = 8;
        note += '+ 8.0 : Elite podium rate (' + (podiumRate * 100).toFixed(0) + '%) at this distance\n';
    } else if (podiumRate >= 0.70) {
        podiumScore = 7;
        note += '+ 7.0 : Excellent podium rate (' + (podiumRate * 100).toFixed(0) + '%) at this distance\n';
    } else if (podiumRate >= 0.55) {
        podiumScore = 6;
        note += '+ 6.0 : Strong podium rate (' + (podiumRate * 100).toFixed(0) + '%) at this distance\n';
    } else if (podiumRate >= 0.40) {
        podiumScore = 4;
        note += '+ 4.0 : Good podium rate (' + (podiumRate * 100).toFixed(0) + '%) at this distance\n';
    } else if (podiumRate >= 0.25) {
        podiumScore = 2;
        note += '+ 2.0 : Moderate podium rate (' + (podiumRate * 100).toFixed(0) + '%) at this distance\n';
    } else {
        podiumScore = 0;
        note += '+ 0.0 : Poor podium rate (' + (podiumRate * 100).toFixed(0) + '%) at this distance\n';
    }
    
    let undefeatedBonus = 0;
    if (wins === runs && runs >= 2) {
        if (runs >= 5) {
            undefeatedBonus = 12;
            note += '+ 12.0 : UNDEFEATED in ' + runs + ' runs at this distance! (5+ runs)\n';
        } else if (runs >= 4) {
            undefeatedBonus = 11;
            note += '+ 11.0 : UNDEFEATED in ' + runs + ' runs at this distance! (4 runs)\n';
        } else if (runs >= 3) {
            undefeatedBonus = 9;
            note += '+ 9.0 : UNDEFEATED in ' + runs + ' runs at this distance! (3 runs)\n';
        } else {
            undefeatedBonus = 6;
            note += '+ 6.0 : UNDEFEATED in ' + runs + ' runs at this distance! (2 runs)\n';
        }
    }
    
    let subtotal = winScore + podiumScore + undefeatedBonus;
    
    let confidenceMultiplier = 1.0;
    let confidenceNote = '';
    
    if (runs >= 10) {
        confidenceMultiplier = 1.0;
        confidenceNote = ' [High confidence: ' + runs + ' runs]';
    } else if (runs >= 6) {
        confidenceMultiplier = 0.9;
        confidenceNote = ' [Good confidence: ' + runs + ' runs]';
    } else if (runs >= 3) {
        confidenceMultiplier = 0.75;
        confidenceNote = ' [Medium confidence: ' + runs + ' runs]';
    } else {
        confidenceMultiplier = 0.6;
        confidenceNote = ' [Low confidence: ' + runs + ' runs]';
    }
    
    addScore = subtotal * confidenceMultiplier;
    
    if (runs >= 5 && wins === 0 && podiumRate < 0.20) {
        addScore -= 6;
        note += '- 6.0 : Poor performance at this distance (' + runs + ' runs, 0 wins, <20% podium)\n';
    }
    
    note += '= ' + addScore.toFixed(1) + ' : Total distance score' + confidenceNote + '\n';
    
    return [addScore, note];
}

function checkTrackForm(racingForm) {
    let addScore = 0;
    let note = '';
    
    if (typeof racingForm !== 'string') {
        note += 'Track form not string. Received type: ' + typeof racingForm + '\n';
        return [addScore, note];
    }
    
    const numbers = racingForm.split(/[:\-]/).map(s => Number(s.trim()));
    
    if (numbers.length != 4) {
        note += 'Track form incorrect format. Received: ' + racingForm + '\n';
        return [addScore, note];
    }
    
    const runs = numbers[0];
    const wins = numbers[1];
    const seconds = numbers[2];
    const thirds = numbers[3];
    const podiums = wins + seconds + thirds;
    
    if (podiums > runs) {
        note += 'More podiums than runs?? Received: ' + racingForm + '\n';
        return [addScore, note];
    }
    
    if (runs === 0) {
        note += '+ 0.0 : No runs at this track\n';
        return [addScore, note];
    }
    
    const winRate = wins / runs;
    const podiumRate = podiums / runs;
    
    let winScore = 0;
    if (winRate >= 0.51) {
        winScore = 6;
        note += '+ 6.0 : Exceptional win rate (' + (winRate * 100).toFixed(0) + '%) at this track\n';
    } else if (winRate >= 0.36) {
        winScore = 5;
        note += '+ 5.0 : Strong win rate (' + (winRate * 100).toFixed(0) + '%) at this track\n';
    } else if (winRate >= 0.26) {
        winScore = 4;
        note += '+ 4.0 : Good win rate (' + (winRate * 100).toFixed(0) + '%) at this track\n';
    } else if (winRate >= 0.16) {
        winScore = 2;
        note += '+ 2.0 : Moderate win rate (' + (winRate * 100).toFixed(0) + '%) at this track\n';
    } else if (winRate >= 0.01) {
        winScore = 1;
        note += '+ 1.0 : Low win rate (' + (winRate * 100).toFixed(0) + '%) at this track\n';
    } else {
        winScore = 0;
        note += '+ 0.0 : No wins at this track\n';
    }
    
    let podiumScore = 0;
    if (podiumRate >= 0.85) {
        podiumScore = 6;
        note += '+ 6.0 : Elite podium rate (' + (podiumRate * 100).toFixed(0) + '%) at this track\n';
    } else if (podiumRate >= 0.70) {
        podiumScore = 5;
        note += '+ 5.0 : Excellent podium rate (' + (podiumRate * 100).toFixed(0) + '%) at this track\n';
    } else if (podiumRate >= 0.55) {
        podiumScore = 4;
        note += '+ 4.0 : Strong podium rate (' + (podiumRate * 100).toFixed(0) + '%) at this track\n';
    } else if (podiumRate >= 0.40) {
        podiumScore = 3;
        note += '+ 3.0 : Good podium rate (' + (podiumRate * 100).toFixed(0) + '%) at this track\n';
    } else if (podiumRate >= 0.25) {
        podiumScore = 1;
        note += '+ 1.0 : Moderate podium rate (' + (podiumRate * 100).toFixed(0) + '%) at this track\n';
    } else {
        podiumScore = 0;
        note += '+ 0.0 : Poor podium rate (' + (podiumRate * 100).toFixed(0) + '%) at this track\n';
    }
    
    let undefeatedBonus = 0;
    if (wins === runs && runs >= 2) {
        if (runs >= 5) {
            undefeatedBonus = 10;
            note += '+ 10.0 : UNDEFEATED in ' + runs + ' runs at this track! (5+ runs)\n';
        } else if (runs >= 4) {
            undefeatedBonus = 9;
            note += '+ 9.0 : UNDEFEATED in ' + runs + ' runs at this track! (4 runs)\n';
        } else if (runs >= 3) {
            undefeatedBonus = 7;
            note += '+ 7.0 : UNDEFEATED in ' + runs + ' runs at this track! (3 runs)\n';
        } else {
            undefeatedBonus = 5;
            note += '+ 5.0 : UNDEFEATED in ' + runs + ' runs at this track! (2 runs)\n';
        }
    }
    
    let subtotal = winScore + podiumScore + undefeatedBonus;
    
    let confidenceMultiplier = 1.0;
    let confidenceNote = '';
    
    if (runs >= 7) {
        confidenceMultiplier = 1.0;
        confidenceNote = ' [High confidence: ' + runs + ' runs]';
    } else if (runs >= 4) {
        confidenceMultiplier = 0.85;
        confidenceNote = ' [Good confidence: ' + runs + ' runs]';
    } else if (runs >= 2) {
        confidenceMultiplier = 0.7;
        confidenceNote = ' [Medium confidence: ' + runs + ' runs]';
    } else {
        confidenceMultiplier = 0.6;
        confidenceNote = ' [Low confidence: ' + runs + ' run]';
    }
    
    addScore = subtotal * confidenceMultiplier;
    
    if (runs >= 5 && wins === 0 && podiumRate < 0.20) {
        addScore -= 5;
        note += '- 5.0 : Poor performance at this track (' + runs + ' runs, 0 wins, <20% podium)\n';
    }
    
    note += '= ' + addScore.toFixed(1) + ' : Total track score' + confidenceNote + '\n';
    
    return [addScore, note];
}

function checkTrackDistanceForm(racingForm) {
    let addScore = 0;
    let note = '';
    
    if (typeof racingForm !== 'string') {
        note += 'Track+Distance form not string. Received type: ' + typeof racingForm + '\n';
        return [addScore, note];
    }
    
    const numbers = racingForm.split(/[:\-]/).map(s => Number(s.trim()));
    
    if (numbers.length != 4) {
        note += 'Track+Distance form incorrect format. Received: ' + racingForm + '\n';
        return [addScore, note];
    }
    
    const runs = numbers[0];
    const wins = numbers[1];
    const seconds = numbers[2];
    const thirds = numbers[3];
    const podiums = wins + seconds + thirds;
    
    if (podiums > runs) {
        note += 'More podiums than runs?? Received: ' + racingForm + '\n';
        return [addScore, note];
    }
    
    if (runs === 0) {
        note += '+ 0.0 : No runs at this track+distance\n';
        return [addScore, note];
    }
    
    const winRate = wins / runs;
    const podiumRate = podiums / runs;
    
    let winScore = 0;
    if (winRate >= 0.51) {
        winScore = 8;
        note += '+ 8.0 : Exceptional win rate (' + (winRate * 100).toFixed(0) + '%) at this track+distance\n';
    } else if (winRate >= 0.36) {
        winScore = 7;
        note += '+ 7.0 : Strong win rate (' + (winRate * 100).toFixed(0) + '%) at this track+distance\n';
    } else if (winRate >= 0.26) {
        winScore = 5;
        note += '+ 5.0 : Good win rate (' + (winRate * 100).toFixed(0) + '%) at this track+distance\n';
    } else if (winRate >= 0.16) {
        winScore = 3;
        note += '+ 3.0 : Moderate win rate (' + (winRate * 100).toFixed(0) + '%) at this track+distance\n';
    } else if (winRate >= 0.01) {
        winScore = 1;
        note += '+ 1.0 : Low win rate (' + (winRate * 100).toFixed(0) + '%) at this track+distance\n';
    } else {
        winScore = 0;
        note += '+ 0.0 : No wins at this track+distance\n';
    }
    
    let podiumScore = 0;
    if (podiumRate >= 0.85) {
        podiumScore = 8;
        note += '+ 8.0 : Elite podium rate (' + (podiumRate * 100).toFixed(0) + '%) at this track+distance\n';
    } else if (podiumRate >= 0.70) {
        podiumScore = 7;
        note += '+ 7.0 : Excellent podium rate (' + (podiumRate * 100).toFixed(0) + '%) at this track+distance\n';
    } else if (podiumRate >= 0.55) {
        podiumScore = 6;
        note += '+ 6.0 : Strong podium rate (' + (podiumRate * 100).toFixed(0) + '%) at this track+distance\n';
    } else if (podiumRate >= 0.40) {
        podiumScore = 4;
        note += '+ 4.0 : Good podium rate (' + (podiumRate * 100).toFixed(0) + '%) at this track+distance\n';
    } else if (podiumRate >= 0.25) {
        podiumScore = 2;
        note += '+ 2.0 : Moderate podium rate (' + (podiumRate * 100).toFixed(0) + '%) at this track+distance\n';
    } else {
        podiumScore = 0;
        note += '+ 0.0 : Poor podium rate (' + (podiumRate * 100).toFixed(0) + '%) at this track+distance\n';
    }
    
    let undefeatedBonus = 0;
    if (wins === runs && runs >= 2) {
        if (runs >= 5) {
            undefeatedBonus = 12;
            note += '+ 12.0 : UNDEFEATED in ' + runs + ' runs at this track+distance! (5+ runs)\n';
        } else if (runs >= 4) {
            undefeatedBonus = 11;
            note += '+ 11.0 : UNDEFEATED in ' + runs + ' runs at this track+distance! (4 runs)\n';
        } else if (runs >= 3) {
            undefeatedBonus = 9;
            note += '+ 9.0 : UNDEFEATED in ' + runs + ' runs at this track+distance! (3 runs)\n';
        } else {
            undefeatedBonus = 6;
            note += '+ 6.0 : UNDEFEATED in ' + runs + ' runs at this track+distance! (2 runs)\n';
        }
    }
    
    let subtotal = winScore + podiumScore + undefeatedBonus;
    
    let confidenceMultiplier = 1.0;
    let confidenceNote = '';
    
    if (runs >= 5) {
        confidenceMultiplier = 1.0;
        confidenceNote = ' [High confidence: ' + runs + ' runs]';
    } else if (runs >= 3) {
        confidenceMultiplier = 0.8;
        confidenceNote = ' [Good confidence: ' + runs + ' runs]';
    } else if (runs >= 2) {
        confidenceMultiplier = 0.6;
        confidenceNote = ' [Medium confidence: ' + runs + ' runs]';
    } else {
        confidenceMultiplier = 0.5;
        confidenceNote = ' [Low confidence: ' + runs + ' run]';
    }
    
    addScore = subtotal * confidenceMultiplier;
    
    if (runs >= 5 && wins === 0 && podiumRate < 0.20) {
        addScore -= 6;
        note += '- 6.0 : Poor performance at this track+distance (' + runs + ' runs, 0 wins, <20% podium)\n';
    }
    
    note += '= ' + addScore.toFixed(1) + ' : Total track+distance score' + confidenceNote + '\n';
    
    return [addScore, note];
}


function checkLastDistance(horseToCheck) {
    const dist = horseToCheck['distance']
    const prevDist = horseToCheck['form distance']
    var addScore = 0;
    var note = '';
    if (prevDist > 0) {
        if (dist > prevDist) {
            // if current distance longer than previous distance
            addScore += 1;
            note += '+ 1.0 : Longer dist than previous\n';
        }
        if (dist < prevDist) {
            // if current distance shorter than previous distance
            addScore -= 1;
            note += '- 1.0 : Shorter dist than previous\n';
        }
    }
    return [addScore, note];
}

function checkDaysSinceLastRun(meetingDate, formMeetingDate) {
    let addScore = 0;
    let note = '';
    
    // Validate inputs
    if (!meetingDate || !formMeetingDate) {
        return [0, ''];
    }
    
    // Parse dates - meeting date is DD/MM/YYYY, form date might be DD/MM/YY or DD/MM/YYYY
    const parseDate = (dateStr) => {
        if (!dateStr) return null;
        
        // Remove time portion if present: "11/10/2025 00:00:00" â†’ "11/10/2025"
        let datePart = dateStr.split(' ')[0];
        
        // Split DD/MM/YYYY or DD/MM/YY
        const parts = datePart.split('/');
        if (parts.length !== 3) return null;
        
        const day = parseInt(parts[0]);
        const month = parseInt(parts[1]) - 1; // JavaScript months are 0-indexed
        let year = parseInt(parts[2]);
        
        // If year is 2-digit, convert to 4-digit
        if (year < 100) {
            // Assume years 00-50 are 2000-2050, and 51-99 are 1951-1999
            year += (year <= 50) ? 2000 : 1900;
        }
        
        return new Date(year, month, day);
    };
    
    const todayDate = parseDate(meetingDate);
    const lastRunDate = parseDate(formMeetingDate);
    
    if (!todayDate || !lastRunDate) {
        return [0, ''];
    }
    
    // Calculate days difference
    const millisecondsPerDay = 1000 * 60 * 60 * 24;
    const daysSinceLastRun = Math.floor((todayDate - lastRunDate) / millisecondsPerDay);
    
    // Apply penalties/bonuses based on days since last run
    if (daysSinceLastRun >= 365) {
        // Over a year - massive penalty
        addScore = -30;
        note += `-30.0 : Too fresh - ${daysSinceLastRun} days since last run (over 1 year!)\n`;
    } else if (daysSinceLastRun >= 250) {
        // 250+ days - very big penalty
        addScore = -25;
        note += `-25.0 : Too fresh - ${daysSinceLastRun} days since last run\n`;
    } else if (daysSinceLastRun >= 200) {
        // 200+ days - big penalty
        addScore = -20;
        note += `-20.0 : Too fresh - ${daysSinceLastRun} days since last run\n`;
    } else if (daysSinceLastRun >= 150) {
        // 150+ days - significant penalty
        addScore = -15;
        note += `-15.0 : Too fresh - ${daysSinceLastRun} days since last run\n`;
    } else if (daysSinceLastRun <= 7) {
        // 7 days or less - quick backup, BIG bonus (strongly outperforms market)
        addScore = 15;
        note += `+15.0 : Quick backup - only ${daysSinceLastRun} days since last run (market underrates!)\n`;
    }
    // 8-149 days is the sweet spot - no penalty or bonus
    
    return [addScore, note];
}
function checkMargin(formPosition, formMargin) {
    let addScore = 0;
    let note = '';
    
    // Validate inputs
    if (!formPosition || !formMargin) {
        return [0, ''];
    }
    
    // Parse position and margin
    const position = parseInt(formPosition);
    const margin = parseFloat(formMargin);
    
    // Check if parsing was successful
    if (isNaN(position) || isNaN(margin)) {
        return [0, ''];
    }
    
    // WINNERS (position = 1)
    if (position === 1) {
        if (margin >= 5.0) {
            addScore = 10;
            note += `+10.0 : Dominant last start win by ${margin.toFixed(1)}L\n`;
        } else if (margin >= 2.0) {
            addScore = 7;
            note += `+ 7.0 : Comfortable last start win by ${margin.toFixed(1)}L\n`;
        } else if (margin >= 0.5) {
            addScore = 5;
            note += `+ 5.0 : Narrow last start win by ${margin.toFixed(1)}L\n`;
        } else {
            addScore = 3;
            note += `+ 3.0 : Photo finish last start win by ${margin.toFixed(1)}L\n`;
        }
    }
    // PLACE GETTERS (position = 2 or 3)
    else if (position === 2 || position === 3) {
        if (margin <= 1.0) {
            addScore = 5;
            note += `+ 5.0 : Narrow loss (${position}${position === 2 ? 'nd' : 'rd'}) by ${margin.toFixed(1)}L - very competitive\n`;
        } else if (margin <= 2.0) {
            addScore = 3;
            note += `+ 3.0 : Close loss (${position}${position === 2 ? 'nd' : 'rd'}) by ${margin.toFixed(1)}L\n`;
        } else if (margin <= 3.5) {
            addScore = 0;
            note += '';
        } else {
            addScore = -5;
            note += `- 5.0 : Beaten badly (${position}${position === 2 ? 'nd' : 'rd'}) by ${margin.toFixed(1)}L\n`;
        }
    }
    // MIDFIELD OR BACK (position 4+)
    else if (position >= 4) {
        if (margin <= 3.0) {
            addScore = 0;
            note += '';
        } else if (margin <= 6.0) {
            addScore = -3;
            note += `- 3.0 : Beaten clearly (${position}th) by ${margin.toFixed(1)}L\n`;
        } else if (margin <= 10.0) {
            addScore = -7;
            note += `- 7.0 : Well beaten (${position}th) by ${margin.toFixed(1)}L\n`;
        } else {
            addScore = -15;
            note += `-15.0 : Demolished (${position}th) by ${margin.toFixed(1)}L - not competitive\n`;
        }
    }
    
    return [addScore, note];
}

// ========================================
// CLASS SCORING SYSTEM (0-130 Scale)
// ========================================

// === PARSE CLASS STRING ===
function parseClassType(classString) {
    if (!classString) return null;
    
    const str = classString.trim();
    
    // Group races
    if (/Group\s*[123]/i.test(str)) {
        const level = parseInt(str.match(/[123]/)[0]);
        return { type: 'Group', level: level, raw: str };
    }
    
    // Listed
    if (/Listed/i.test(str)) {
        return { type: 'Listed', level: null, raw: str };
    }
    
    // Benchmark (handles "Benchmark 80" or "Bench. 80" or "BM80")
    const bmMatch = str.match(/(?:Benchmark|Bench\.?|BM)\s*(\d+)/i);
    if (bmMatch) {
        const level = parseInt(bmMatch[1]);
        return { type: 'Benchmark', level: level, raw: str };
    }
    
    // Class (handles "Class 3" or "Cls 2")
    const classMatch = str.match(/(?:Class|Cls)\s*(\d+)/i);
    if (classMatch) {
        const level = parseInt(classMatch[1]);
        return { type: 'Class', level: level, raw: str };
    }
    
    // Restricted (handles "Rest. 62")
    const restMatch = str.match(/Rest\.?\s*(\d+)/i);
    if (restMatch) {
        const level = parseInt(restMatch[1]);
        return { type: 'Restricted', level: level, raw: str };
    }
    
    // Rating (handles "RS105" or "Rating 0-105")
    const ratingMatch = str.match(/(?:RS|Rating)\s*(?:0-)?(\d+)/i);
    if (ratingMatch) {
        const level = parseInt(ratingMatch[1]);
        return { type: 'Rating', level: level, raw: str };
    }
    
    // Maiden
    if (/Maiden|Mdn/i.test(str)) {
        return { type: 'Maiden', level: null, raw: str };
    }
    
    // Open (catch-all for Opens)
    if (/Open/i.test(str)) {
        return { type: 'Open', level: null, raw: str };
    }
    
    // Highway
    if (/Highway/i.test(str)) {
        return { type: 'Highway', level: null, raw: str };
    }
    
    // Special/Novice/etc
    if (/Special|Spec|Nov/i.test(str)) {
        return { type: 'Special', level: null, raw: str };
    }
    
    // Unknown
    return { type: 'Unknown', level: null, raw: str };
}

// === EXTRACT PRIZE MONEY ===
function extractFirstPrize(prizeString) {
    if (!prizeString) return null;
    
    // Match pattern: "1st $82500" or "1st  $82,500"
    const match = prizeString.match(/1st\s+\$([0-9,]+)/i);
    if (match) {
        // Remove commas and convert to number
        return parseInt(match[1].replace(/,/g, ''));
    }
    return null;
}

// === CALCULATE SCORE (0-130) ===
function calculateClassScore(classString, prizeString) {
    const parsed = parseClassType(classString);
    if (!parsed) return 0;
    
    // Benchmark: Use BM number directly (BM1-BM100)
    if (parsed.type === 'Benchmark' && parsed.level !== null) {
        return Math.min(100, Math.max(1, parsed.level));
    }
    
    // Group races: Fixed scores
    if (parsed.type === 'Group') {
        if (parsed.level === 1) return 130;
        if (parsed.level === 2) return 122;
        if (parsed.level === 3) return 115;
    }
    
    // Listed: Fixed score
    if (parsed.type === 'Listed') {
        return 108;
    }
    
    // Everything else: Use prize money
    const prize = extractFirstPrize(prizeString);
    if (!prize) {
        // Fallback estimates if no prize money available
        if (parsed.type === 'Class') {
            if (parsed.level === 1) return 40;
            if (parsed.level === 2) return 55;
            if (parsed.level === 3) return 65;
            if (parsed.level === 4) return 75;
            if (parsed.level === 5) return 85;
            if (parsed.level === 6) return 92;
        }
        if (parsed.type === 'Maiden') return 50;
        if (parsed.type === 'Open') return 95;
        if (parsed.type === 'Restricted') return parsed.level ? parsed.level - 10 : 50;
        if (parsed.type === 'Rating') return parsed.level ? Math.min(100, parsed.level - 5) : 80;
        if (parsed.type === 'Highway') return 70;
        if (parsed.type === 'Special') return 45;
        return 50; // Default unknown
    }
    
    // Prize money to score conversion
    if (prize >= 2000000) return 130;
    if (prize >= 1000000) return 125 + ((prize - 1000000) / 1000000) * 5;
    if (prize >= 600000) return 120 + ((prize - 600000) / 400000) * 5;
    if (prize >= 400000) return 115 + ((prize - 400000) / 200000) * 5;
    if (prize >= 250000) return 110 + ((prize - 250000) / 150000) * 5;
    if (prize >= 150000) return 105 + ((prize - 150000) / 100000) * 5;
    if (prize >= 100000) return 100 + ((prize - 100000) / 50000) * 5;
    if (prize >= 80000) return 95 + ((prize - 80000) / 20000) * 5;
    if (prize >= 60000) return 88 + ((prize - 60000) / 20000) * 7;
    if (prize >= 45000) return 80 + ((prize - 45000) / 15000) * 8;
    if (prize >= 35000) return 72 + ((prize - 35000) / 10000) * 8;
    if (prize >= 25000) return 64 + ((prize - 25000) / 10000) * 8;
    if (prize >= 18000) return 56 + ((prize - 18000) / 7000) * 8;
    if (prize >= 12000) return 48 + ((prize - 12000) / 6000) * 8;
    if (prize >= 8000) return 40 + ((prize - 8000) / 4000) * 8;
    if (prize >= 5000) return 32 + ((prize - 5000) / 3000) * 8;
    return 25 + (prize / 5000) * 7;
}

// === COMPARE CLASSES ===
function compareClasses(newClass, formClass, newPrizemoneyString, formPrizemoneyString) {
    // Calculate scores using our 0-130 system
    const todayScore = calculateClassScore(newClass, newPrizemoneyString);
    const lastScore = calculateClassScore(formClass, formPrizemoneyString);
    
    // Calculate the difference
    const scoreDiff = todayScore - lastScore;
    
    let addScore = 0;
    let note = '';
    
    // Interpret the score difference
    if (scoreDiff > 0) {
        // Stepping UP in class (harder race)
        addScore = scoreDiff * -1.0; // Negative points for stepping up
        note += addScore.toFixed(1) + ': Stepping UP ' + scoreDiff.toFixed(1) + ' class points; "' + formClass + '" (' + lastScore.toFixed(1) + ') to "' + newClass + '" (' + todayScore.toFixed(1) + ')\n';
    } else if (scoreDiff < 0) {
        // Stepping DOWN in class (easier race)
        addScore = Math.abs(scoreDiff) * 1.0; // Positive points for stepping down
        note += '+ ' + addScore.toFixed(1) + ': Stepping DOWN ' + Math.abs(scoreDiff).toFixed(1) + ' class points; "' + formClass + '" (' + lastScore.toFixed(1) + ') to "' + newClass + '" (' + todayScore.toFixed(1) + ')\n';
    } else {
        // Same class level
        note += '0.0: Same class level; "' + formClass + '" to "' + newClass + '" (both ' + todayScore.toFixed(1) + ')\n';
    }
    
    return [addScore, note];
}

// Form Price Scoring System: +50 to -50 points
const formPriceScores = {
    1.01: 50, 1.02: 50, 1.03: 50, 1.04: 49, 1.05: 49, 1.06: 49, 1.07: 49, 1.08: 48, 1.09: 48, 1.1: 48,
    1.11: 48, 1.12: 47, 1.13: 47, 1.14: 47, 1.15: 47, 1.16: 46, 1.17: 46, 1.18: 46, 1.19: 46, 1.2: 45,
    1.21: 45, 1.22: 45, 1.23: 45, 1.24: 44, 1.25: 44, 1.26: 44, 1.27: 44, 1.28: 43, 1.29: 43, 1.3: 43,
    1.31: 43, 1.32: 42, 1.33: 42, 1.34: 42, 1.35: 42, 1.36: 41, 1.37: 41, 1.38: 41, 1.39: 41, 1.4: 40,
    1.41: 40, 1.42: 40, 1.43: 40, 1.44: 39, 1.45: 39, 1.46: 39, 1.47: 39, 1.48: 38, 1.49: 38, 1.5: 38,
    1.51: 38, 1.52: 37, 1.53: 37, 1.54: 37, 1.55: 37, 1.56: 36, 1.57: 36, 1.58: 36, 1.59: 36, 1.6: 35,
    1.61: 35, 1.62: 35, 1.63: 35, 1.64: 34, 1.65: 34, 1.66: 34, 1.67: 34, 1.68: 33, 1.69: 33, 1.7: 33,
    1.71: 33, 1.72: 32, 1.73: 32, 1.74: 32, 1.75: 32, 1.76: 31, 1.77: 31, 1.78: 31, 1.79: 31, 1.8: 30,
    1.81: 30, 1.82: 30, 1.83: 30, 1.84: 29, 1.85: 29, 1.86: 29, 1.87: 29, 1.88: 28, 1.89: 28, 1.9: 28,
    1.91: 28, 1.92: 27, 1.93: 27, 1.94: 27, 1.95: 27, 1.96: 26, 1.97: 26, 1.98: 26, 1.99: 26, 2: 25,
    2.02: 25, 2.04: 24, 2.06: 24, 2.08: 24, 2.1: 23, 2.12: 23, 2.14: 23, 2.16: 22, 2.18: 22, 2.2: 22,
    2.22: 21, 2.24: 21, 2.26: 21, 2.28: 20, 2.3: 20, 2.32: 20, 2.34: 19, 2.36: 19, 2.38: 19, 2.4: 18,
    2.42: 18, 2.44: 18, 2.46: 17, 2.48: 17, 2.5: 17, 2.52: 16, 2.54: 16, 2.56: 16, 2.58: 15, 2.6: 15,
    2.62: 15, 2.64: 14, 2.66: 14, 2.68: 14, 2.7: 13, 2.72: 13, 2.74: 13, 2.76: 12, 2.78: 12, 2.8: 12,
    2.82: 11, 2.84: 11, 2.86: 11, 2.88: 10, 2.9: 10, 2.92: 10, 2.94: 9, 2.96: 9, 2.98: 9, 3: 8,
    3.05: 8, 3.1: 8, 3.15: 8, 3.2: 7, 3.25: 7, 3.3: 7, 3.35: 7, 3.4: 6, 3.45: 6, 3.5: 6,
    3.55: 6, 3.6: 5, 3.65: 5, 3.7: 5, 3.75: 5, 3.8: 4, 3.85: 4, 3.9: 4, 3.95: 4, 4: 3,
    4.1: 3, 4.2: 3, 4.3: 3, 4.4: 3, 4.5: 3, 4.6: 3, 4.7: 3, 4.8: 3, 4.9: 3, 5: 3,
    5.1: 2, 5.2: 2, 5.3: 2, 5.4: 2, 5.5: 2, 5.6: 2, 5.7: 2, 5.8: 2, 5.9: 2, 6: 2,
    6.2: 2, 6.4: 2, 6.6: 2, 6.8: 2, 7: 2, 7.2: 2, 7.4: 2, 7.6: 2, 7.8: 2, 8: 2,
    8.2: 2, 8.4: 2, 8.6: 2, 8.8: 2, 9: 2, 9.2: 2, 9.4: 2, 9.6: 2, 9.8: 2, 10: 2,
    10.5: 2, 11: 2, 11.5: 2, 12: 1, 12.5: 1, 13: 1, 13.5: 1, 14: 0, 14.5: 0, 15: 0,
    15.5: -1, 16: -2, 16.5: -2, 17: -3, 17.5: -4, 18: -5, 18.5: -5, 19: -6, 19.5: -7, 20: -9,
    21: -11, 22: -12, 23: -13, 24: -14, 25: -16, 26: -17, 27: -18, 28: -20, 29: -21, 30: -22,
    32: -25, 34: -26, 36: -28, 38: -29, 40: -31, 42: -32, 44: -34, 46: -35, 48: -37, 50: -38,
    55: -40, 60: -41, 65: -42, 70: -43, 75: -44, 80: -44, 85: -45, 90: -45, 95: -46, 100: -46,
    110: -47, 120: -47, 130: -48, 140: -48, 150: -49, 160: -49, 170: -50, 180: -50, 190: -50, 200: -50,
    250: -50, 300: -50, 350: -50, 400: -50, 450: -50, 500: -50
};

function checkFormPrice(formPrice) {
    let addScore = 0;
    let note = '';
    
    // Handle no valid form price case
    if (formPrice === null || formPrice === undefined) {
        return [0, 'Error: No form price available\n'];
    }
    
    // Convert to number if it's a string
    const numericPrice = typeof formPrice === 'string' ? parseFloat(formPrice) : formPrice;
    
    // Validate it's a valid number
    if (isNaN(numericPrice)) {
        return [0, `Error: Form price "${formPrice}" is not a valid number\n`];
    }
    
    // Validate range
    if (numericPrice < 1.01 || numericPrice > 500.00) {
        return [0, `Error: Form price $${numericPrice} outside valid range (1.01-500.00)\n`];
    }
    
    // Round to 2 decimal places for lookup
    const roundedPrice = Math.round(numericPrice * 100) / 100;
    
    // Try exact lookup first
    if (formPriceScores[roundedPrice] !== undefined) {
        addScore = formPriceScores[roundedPrice];
        if (addScore > 0) {
            note += `+${addScore}.0 : Form price $${roundedPrice.toFixed(2)} (well-backed)\n`;
        } else if (addScore === 0) {
            note += `+0.0 : Form price $${roundedPrice.toFixed(2)} (neutral)\n`;
        } else {
            note += `${addScore}.0 : Form price $${roundedPrice.toFixed(2)} (outsider penalty)\n`;
        }
    } else {
        // Handle prices not in the lookup table with interpolation
        const sortedPrices = Object.keys(formPriceScores).map(Number).sort((a, b) => a - b);
        const closestLower = sortedPrices.filter(p => p < roundedPrice).pop();
        const closestHigher = sortedPrices.filter(p => p > roundedPrice)[0];
        
        if (closestLower && closestHigher) {
            // Linear interpolation
            const lowerScore = formPriceScores[closestLower];
            const higherScore = formPriceScores[closestHigher];
            const ratio = (roundedPrice - closestLower) / (closestHigher - closestLower);
            addScore = Math.round(lowerScore + (higherScore - lowerScore) * ratio);
            
            if (addScore > 0) {
                note += `+${addScore}.0 : Form price $${roundedPrice.toFixed(2)} (interpolated)\n`;
            } else if (addScore === 0) {
                note += `+0.0 : Form price $${roundedPrice.toFixed(2)} (interpolated)\n`;
            } else {
                note += `${addScore}.0 : Form price $${roundedPrice.toFixed(2)} (interpolated)\n`;
            }
        } else {
            return [0, `Error: Form price $${roundedPrice.toFixed(2)} could not be scored\n`];
        }
    }
    
    return [addScore, note];
}
// Add this function after the checkFormPrice function
function checkFirstUpSecondUp(horseRow) {
    let addScore = 0;
    let note = '';
    
    const last10 = String(horseRow['horse last10'] || '');
    const firstUpRecord = horseRow['horse record first up'];
    const secondUpRecord = horseRow['horse record second up'];
    
    // Determine if horse is first up or second up today
    let isFirstUp = false;
    let isSecondUp = false;
    
    // Check the most recent run (rightmost character) for first up detection
    if (last10.toLowerCase().endsWith('x')) {
        isFirstUp = true;
    }
    // Check for second up: exactly one run after most recent 'x'
    // Pattern: ...x[digit] at the end (exactly 2 characters from spell)
    else if (last10.length >= 2) {
        const lastChar = last10.charAt(last10.length - 1);
        const secondLastChar = last10.charAt(last10.length - 2);
        
        // Second up means: previous run was 'x' and current run is a single digit
        if (secondLastChar.toLowerCase() === 'x' && /\d/.test(lastChar)) {
            isSecondUp = true;
        }
    }
    
    // Function to check if a record is undefeated
    const isUndefeated = (record) => {
        if (typeof record !== 'string') return false;
        
        const numbers = record.split(/[:\-]/).map(Number);
        if (numbers.length !== 4) return false;
        
        const [runs, wins, seconds, thirds] = numbers;
        
        // Must have at least 1 run, all runs must be wins, no seconds or thirds
        return runs > 0 && wins === runs && seconds === 0 && thirds === 0;
    };
    
    // Check first up specialist
    if (isFirstUp && isUndefeated(firstUpRecord)) {
        addScore += 15;
        note += `+15.0 : First up specialist (${firstUpRecord})\n`;
    }
    
    // Check second up specialist
    if (isSecondUp && isUndefeated(secondUpRecord)) {
        addScore += 15;
        note += `+15.0 : Second up specialist (${secondUpRecord})\n`;
    }
    
    return [addScore, note];
}

function calculateAverageFormPrices(data) {
    const formPriceGroups = {};
    
    // Group form prices by composite key (horse name + race number)
    data.forEach(entry => {
        const compositeKey = `${entry['horse name']}-${entry['race number']}`;
        const formPrice = parseFloat(entry['form price']);
        
        // Initialize array for this horse-race combination if it doesn't exist
        if (!formPriceGroups[compositeKey]) {
            formPriceGroups[compositeKey] = [];
        }
        
        // Only add valid form prices within the expected range
        if (!isNaN(formPrice) && formPrice >= 1.01 && formPrice <= 500.00) {
            formPriceGroups[compositeKey].push(formPrice);
        }
    });
    
    // Calculate averages for each horse-race combination
    const averages = {};
    Object.keys(formPriceGroups).forEach(key => {
        const prices = formPriceGroups[key];
        if (prices.length > 0) {
            // Calculate average and round to 2 decimal places
            const sum = prices.reduce((total, price) => total + price, 0);
            const average = sum / prices.length;
            averages[key] = Math.round(average * 100) / 100;
        } else {
            // No valid prices found for this horse
            averages[key] = null;
        }
    });
    
    return averages;
}

function parseLastInteger(sectional) {
    const match = sectional.match(/(\d+)m$/);
    return match ? parseInt(match[1], 10) : null; // Return the integer or null if not found
}
function getLowestSectionalsByRace(data) {
  // Filter out invalid rows first
  const validData = data.filter(entry => {
    // Check if all required fields exist
    if (!entry['race number'] || !entry['horse name'] || !entry['sectional']) {
      return false;
    }
    
    // Check if horse name is valid (not just the header text)
    const horseName = entry['horse name'].toString().trim().toLowerCase();
    if (horseName === 'horse name' || horseName === '' || horseName === 'nan' || horseName === 'null' || horseName === 'undefined') {
      return false;
    }
    
    // Check if race number is valid
    const raceNum = parseInt(entry['race number']);
    if (isNaN(raceNum) || raceNum <= 0) {
      return false;
    }
    
    // Check if sectional format is recognizable (even if 0 seconds)
    const sectionalMatch = entry['sectional'].toString().match(/^(\d+\.?\d*)sec (\d+)m$/);
    if (!sectionalMatch) {
      return false;
    }
    
    return true;
  });

  // Group data by race number
  const raceGroups = {};
  validData.forEach(entry => {
    const raceNum = entry['race number'];
    if (!raceGroups[raceNum]) {
      raceGroups[raceNum] = [];
    }
    raceGroups[raceNum].push(entry);
  });

  const results = [];

  // Process each race
  Object.keys(raceGroups).forEach(raceNum => {
    const raceData = raceGroups[raceNum];
    
    // Parse sectional data and check for consistency
    const parsedData = [];
    const distances = new Set();

    raceData.forEach(entry => {
      const sectionalMatch = entry.sectional.match(/^(\d+\.?\d*)sec (\d+)m$/);
      if (sectionalMatch) {
        const time = parseFloat(sectionalMatch[1]);
        const distance = parseInt(sectionalMatch[2]);
        
        // Only consider non-zero sectionals for distance checking
        if (time > 0) {
          distances.add(distance);
        }
        
        parsedData.push({
          ...entry,
          time: time,
          distance: distance
        });
      }
    });

    // If multiple distances, find the most common one
    let targetDistance = null;
    if (distances.size > 1) {
      // Count horses per distance
      const distanceHorseCounts = {};
      distances.forEach(dist => {
        const horsesAtDistance = new Set();
        parsedData.forEach(entry => {
          if (entry.time > 0 && entry.distance === dist) {
            horsesAtDistance.add(entry['horse name']);
          }
        });
        distanceHorseCounts[dist] = horsesAtDistance.size;
      });
      
      // Find distance with most horses
      targetDistance = Object.keys(distanceHorseCounts).reduce((a, b) => 
        distanceHorseCounts[a] > distanceHorseCounts[b] ? a : b
      );
      targetDistance = parseInt(targetDistance);
    } else if (distances.size === 1) {
      targetDistance = [...distances][0];
    }

    // Collect sectional times at target distance with dates
    const horseData = {};
    const allHorses = [...new Set(raceData.map(entry => entry['horse name']))];
    
    // Initialize all horses
    allHorses.forEach(horseName => {
      horseData[horseName] = [];
    });
    
    // Collect sectional times with dates at target distance
    parsedData.forEach(entry => {
      const horseName = entry['horse name'];
      // Only include non-zero sectionals at the target distance
      if (entry.time > 0 && (targetDistance === null || entry.distance === targetDistance)) {
        horseData[horseName].push({
          time: entry.time,
          date: entry['form meeting date']
        });
      }
    });

    // Sort by date (most recent first) for each horse
    Object.keys(horseData).forEach(horseName => {
      horseData[horseName].sort((a, b) => {
        return new Date(b.date) - new Date(a.date);
      });
    });

    // SYSTEM 1: Average of Last 3 Runs
    const averageLast3Data = [];
    const horsesWithoutAverage = [];
    
    Object.keys(horseData).forEach(horseName => {
      const times = horseData[horseName];
      if (times.length > 0) {
        // Take up to 3 most recent runs
        const last3Times = times.slice(0, 3).map(entry => entry.time);
        const average = last3Times.reduce((sum, time) => sum + time, 0) / last3Times.length;
        averageLast3Data.push({
          horseName: horseName,
          averageTime: average,
          runsUsed: last3Times.length
        });
      } else {
        horsesWithoutAverage.push(horseName);
      }
    });

    // Sort by average time (fastest first)
    averageLast3Data.sort((a, b) => a.averageTime - b.averageTime);

    // SYSTEM 2: Best Single Sectional from Last Start Only
    const lastStartData = [];
    const horsesWithoutLastStart = [];
    
    Object.keys(horseData).forEach(horseName => {
      const times = horseData[horseName];
      if (times.length > 0) {
        // Take only the most recent run (index 0 after sorting)
        const lastStartTime = times[0].time;
        lastStartData.push({
          horseName: horseName,
          lastStartTime: lastStartTime
        });
      } else {
        horsesWithoutLastStart.push(horseName);
      }
    });

    // Sort by last start time (fastest first)
    lastStartData.sort((a, b) => a.lastStartTime - b.lastStartTime);

    // Create a map to store scores for each horse
    const horseScores = {};
    allHorses.forEach(horseName => {
      horseScores[horseName] = {
        score: 0,
        note: '',
        hasAverage1st: false,
        hasLastStart1st: false
      };
    });

    // Assign points for System 1: Average of Last 3
    averageLast3Data.forEach((horse, index) => {
      let score = 0;
      let note = '';
      if (index === 0) {
        score = 20;
        note = `+20.0: fastest avg sectional (last ${horse.runsUsed} runs)\n`;
        horseScores[horse.horseName].hasAverage1st = true;
      } else if (index === 1) {
        score = 10;
        note = `+10.0: 2nd fastest avg sectional (last ${horse.runsUsed} runs)\n`;
      } else if (index === 2) {
        score = 5;
        note = `+ 5.0: 3rd fastest avg sectional (last ${horse.runsUsed} runs)\n`;
      }
      horseScores[horse.horseName].score += score;
      horseScores[horse.horseName].note += note;
    });

    // Assign points for System 2: Last Start Only
    lastStartData.forEach((horse, index) => {
      let score = 0;
      let note = '';
      if (index === 0) {
        score = 20;
        note = `+20.0: fastest last start sectional\n`;
        horseScores[horse.horseName].hasLastStart1st = true;
      } else if (index === 1) {
        score = 10;
        note = `+10.0: 2nd fastest last start sectional\n`;
      } else if (index === 2) {
        score = 5;
        note = `+ 5.0: 3rd fastest last start sectional\n`;
      }
      horseScores[horse.horseName].score += score;
      horseScores[horse.horseName].note += note;
    });

    // Add horses without sectionals
    horsesWithoutAverage.forEach(horseName => {
      if (!horseScores[horseName].note) {
        horseScores[horseName].note = '??: No valid sectional\n';
      }
    });

    // Convert to results array
    Object.keys(horseScores).forEach(horseName => {
      results.push({
        'race': raceNum,
        'name': horseName,
        'sectionalScore': horseScores[horseName].score,
        'sectionalNote': horseScores[horseName].note,
        'hasAverage1st': horseScores[horseName].hasAverage1st,
        'hasLastStart1st': horseScores[horseName].hasLastStart1st
      });
    });
  });
  
  return results;
}


function calculateTrueOdds(results, priorStrength = 0.05, troubleshooting, maxRatio = 300.0) {
    // Group horses by race
    const raceGroups = results.reduce((acc, obj) => {
        const raceNumber = obj.horse['race number'];
        if (!acc[raceNumber]) acc[raceNumber] = [];
        acc[raceNumber].push(obj);
        return acc;
    }, {});
    
    // Process each race separately
    Object.values(raceGroups).forEach(raceHorses => {
        const numHorses = raceHorses.length;
        const scores = raceHorses.map(h => h.score);
        
        // Calculate proportional shift to control max ratio
        const minScore = Math.min(...scores);
        const maxScore = Math.max(...scores);
        const range = maxScore - minScore;
        
        // Calculate shift to ensure max ratio doesn't exceed maxRatio
        // If range is small, use a larger shift to prevent extreme ratios
       const minShiftForRatio = range > 0 ? range / (maxRatio - 1) : 1.0;
const basicShift = minScore < 0 ? Math.abs(minScore) + 0.01 : 0;
const shift = Math.max(basicShift, minShiftForRatio * 0.5);
        
        // Apply Dirichlet method
        const adjustedScores = scores.map(s => s + shift);
        const posteriorCounts = adjustedScores.map(score => score + priorStrength);
        const totalCounts = posteriorCounts.reduce((sum, count) => sum + count, 0);
        
        // Calculate base probability (same for all horses in this race)
        const baseProbability = priorStrength / totalCounts;
        
        // Calculate final probabilities and odds for each horse
        raceHorses.forEach((horse, index) => {
            // Win probability
            const winProbability = posteriorCounts[index] / totalCounts;
            
            // Base probability component (same for all horses in race)
            const baseProbabilityPercent = (baseProbability * 100).toFixed(1) + '%';
            
            // Performance-based probability component
            const performanceProbability = (adjustedScores[index] / totalCounts);
            
            // True dollar odds (no bookmaker margin)
            const trueOdds = 1 / (winProbability * 1.10);
            
            // Add all calculated values to horse object
            horse.winProbability = (winProbability * 110).toFixed(1) + '%';
            horse.baseProbability = baseProbabilityPercent; // Same for all horses in this race
            horse.trueOdds = `$${trueOdds.toFixed(2)}`;
            
            // Additional useful info
            horse.rawWinProbability = winProbability * 1.10; // For calculations
            horse.performanceComponent = (performanceProbability * 100).toFixed(1) + '%';
            horse.adjustedScore = adjustedScores[index]; // For debugging
        });
        
        // Verify probabilities sum to 110%
        const totalProb = raceHorses.reduce((sum, horse) => sum + horse.rawWinProbability, 0);
        if (totalProb < 1.09 || totalProb > 1.11) {
            throw new Error(`Race ${raceHorses[0].horse['race number']} probabilities adding to ${(totalProb*100).toFixed(2)}%`);
        }

        // Log race summary if troubleshooting on
        if (troubleshooting) {
            console.log(`\nðŸ“Š RACE ${raceHorses[0].horse['race number']} SUMMARY:`);
            console.log(`Horses: ${numHorses}`);
            console.log(`Score range: ${minScore.toFixed(2)} to ${maxScore.toFixed(2)} (range: ${range.toFixed(2)})`);
            console.log(`Max ratio limit: ${maxRatio}:1`);
            console.log(`Score shift applied: ${shift.toFixed(2)}`);
            console.log(`Base probability per horse: ${(baseProbability * 100).toFixed(1)}%`);
            console.log(`Prior strength: ${priorStrength}`);
            
            // Show actual min/max adjusted score ratio
            const minAdjusted = Math.min(...adjustedScores);
            const maxAdjusted = Math.max(...adjustedScores);
            const actualRatio = maxAdjusted / minAdjusted;
            console.log(`Actual adjusted score ratio: ${actualRatio.toFixed(2)}:1`);
            console.log(`Total probability check: ${(totalProb * 100).toFixed(1)}%`);
            
            // Show odds range
            const allOdds = raceHorses.map(h => parseFloat(h.trueOdds.replace('$', '')));
            const minOdds = Math.min(...allOdds);
            const maxOdds = Math.max(...allOdds);
            console.log(`Odds range: $${minOdds.toFixed(2)} to $${maxOdds.toFixed(2)}`);
        }
    });
    
    return results;
}

function displayResults(analysisResults, isAdvanced, fileName) {
    const resultsDiv = document.getElementById('results');
    
    // If this is the first meeting, clear previous results
    if (resultsDiv.children.length === 0) {
        resultsDiv.innerHTML = '<h2>Analysis Results</h2>';
    }
    
    // Add meeting header
    const meetingHeader = document.createElement('div');
    meetingHeader.style.cssText = 'margin-top: 30px; margin-bottom: 20px;';
    meetingHeader.innerHTML = `<h3 style="color: #2d3748; font-size: 1.5em; border-bottom: 2px solid #667eea; padding-bottom: 10px;">${fileName.replace('.csv', '')}</h3>`;
    resultsDiv.appendChild(meetingHeader);

    // Calculate dashboard statistics
    const dashboardStats = calculateDashboardStats(analysisResults);
    
    // Add PDF download button
    const pdfButtonContainer = document.createElement('div');
    pdfButtonContainer.style.cssText = 'margin-bottom: 15px;';
    const pdfButton = document.createElement('button');
    pdfButton.className = 'pdf-download-btn';
    pdfButton.textContent = 'Download PDF Report';
    pdfButton.onclick = () => {
        // Group horses by race number for PDF
        const raceGroups = {};
        analysisResults.forEach(result => {
            const raceNum = result.horse['race number'];
            if (!raceGroups[raceNum]) {
                raceGroups[raceNum] = [];
            }
            raceGroups[raceNum].push(result);
        });
        generatePDF(fileName, dashboardStats, raceGroups, isAdvanced);
    };
    pdfButtonContainer.appendChild(pdfButton);
    resultsDiv.appendChild(pdfButtonContainer);
    
    // Create and display dashboard
    const dashboard = createDashboard(dashboardStats);
    resultsDiv.appendChild(dashboard);

    // Group horses by race number
    const raceGroups = {};
    analysisResults.forEach(result => {
        const raceNum = result.horse['race number'];
        if (!raceGroups[raceNum]) {
            raceGroups[raceNum] = [];
        }
        raceGroups[raceNum].push(result);
    });

    // Sort race numbers
    const sortedRaceNumbers = Object.keys(raceGroups).sort((a, b) => parseInt(a) - parseInt(b));

    // Create a section for each race
    sortedRaceNumbers.forEach(raceNum => {
        const raceResults = raceGroups[raceNum];
        
        // Create race container
        const raceContainer = document.createElement('div');
        raceContainer.className = 'race-container';
        raceContainer.id = `race-${raceNum}`; // THIS IS THE KEY ID FOR SCROLLING!

        // Create race dashboard (clickable header)
        const raceDashboard = document.createElement('div');
        raceDashboard.className = 'race-dashboard';

        // Race dashboard header
        const dashboardHeader = document.createElement('div');
        dashboardHeader.className = 'race-dashboard-header';

        // Race title with collapse arrow
        const raceTitle = document.createElement('div');
        raceTitle.className = 'race-title';
        raceTitle.innerHTML = `
            <span class="collapse-arrow">â–¼</span>
            <span>Race ${raceNum}</span>
        `;

        dashboardHeader.appendChild(raceTitle);
        raceDashboard.appendChild(dashboardHeader);

        // Top 3 horses preview
        const topHorsesDiv = document.createElement('div');
        topHorsesDiv.className = 'top-horses';

        const top3 = raceResults.slice(0, 3);
        top3.forEach((result, index) => {
            const horseRow = document.createElement('div');
            horseRow.className = 'horse-row';

            const positionBadge = document.createElement('div');
            positionBadge.className = `position-badge ${index === 0 ? 'first' : index === 1 ? 'second' : 'third'}`;
            positionBadge.textContent = index + 1;

            const horseName = document.createElement('div');
            horseName.className = 'horse-name';
            horseName.textContent = result.horse['horse name'];

            const horseStats = document.createElement('div');
            horseStats.className = 'horse-stats';
            horseStats.innerHTML = `
                <div class="stat-item">
                    <span class="stat-label">Score:</span>
                    <span class="stat-value">${result.score.toFixed(1)}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Odds:</span>
                    <span class="stat-value">${result.trueOdds}</span>
                </div>
            `;

            horseRow.appendChild(positionBadge);
            horseRow.appendChild(horseName);
            horseRow.appendChild(horseStats);
            topHorsesDiv.appendChild(horseRow);
        });

        raceDashboard.appendChild(topHorsesDiv);

        // Race stats bar
        const raceStatsBar = document.createElement('div');
        raceStatsBar.className = 'race-stats-bar';

        const scores = raceResults.map(r => r.score);
        const highestScore = Math.max(...scores);
        const lowestScore = Math.min(...scores);
        const gap = highestScore - (scores.length > 1 ? scores[1] : 0);

        raceStatsBar.innerHTML = `
            <div class="race-stat">
                <span class="race-stat-label">Horses:</span>
                <span class="race-stat-value">${raceResults.length}</span>
            </div>
            <div class="race-stat">
                <span class="race-stat-label">High Score:</span>
                <span class="race-stat-value">${highestScore.toFixed(1)}</span>
            </div>
            <div class="race-stat">
                <span class="race-stat-label">Score Gap:</span>
                <span class="race-stat-value">${gap.toFixed(1)}</span>
            </div>
            <div class="race-stat">
                <span class="race-stat-label">Worst Score:</span>
                <span class="race-stat-value worst-score">${lowestScore.toFixed(1)}</span>
            </div>
        `;

        raceDashboard.appendChild(raceStatsBar);
        raceContainer.appendChild(raceDashboard);

        // Create collapsible table container
        const tableContainer = document.createElement('div');
        tableContainer.className = 'race-table-container expanded'; // Start expanded

        // Create table for this race
        const table = document.createElement('table');
        table.border = "1";

        // Create header row
        const headerRow = table.insertRow();
        headerRow.insertCell().innerText = "Position";
        headerRow.insertCell().innerText = "Horse Name";
        headerRow.insertCell().innerText = "Score";
        headerRow.insertCell().innerText = "Odds";
        
        if (isAdvanced) {
            headerRow.insertCell().innerText = "Win Prob.";
            headerRow.insertCell().innerText = "Performance Prob.";
            headerRow.insertCell().innerText = "Base Prob.";
        }
        
        headerRow.insertCell().innerText = "Notes";

        // Populate table with horses from this race only
        raceResults.forEach((result, index) => {
            const row = table.insertRow();
            row.insertCell().innerText = index + 1;
            row.insertCell().innerText = result.horse['horse name'];
            row.insertCell().innerText = result.score.toFixed(1);
            row.insertCell().innerText = result.trueOdds;
            
            if (isAdvanced) {
                row.insertCell().innerText = result.winProbability;
                row.insertCell().innerText = result.performanceComponent;
                row.insertCell().innerText = result.baseProbability;
            }
            
            row.insertCell().innerText = result.notes;
        });

        tableContainer.appendChild(table);
        raceContainer.appendChild(tableContainer);

        // Add click handler to toggle collapse
        raceDashboard.onclick = () => {
            const arrow = raceDashboard.querySelector('.collapse-arrow');
            if (tableContainer.classList.contains('expanded')) {
                tableContainer.classList.remove('expanded');
                tableContainer.classList.add('collapsed');
                arrow.classList.add('collapsed');
            } else {
                tableContainer.classList.remove('collapsed');
                tableContainer.classList.add('expanded');
                arrow.classList.remove('collapsed');
            }
        };

        resultsDiv.appendChild(raceContainer);
    });
}

function calculateDashboardStats(analysisResults) {
    // Group horses by race number
    const raceGroups = analysisResults.reduce((acc, result) => {
        const raceNumber = result.horse['race number'];
        if (!acc[raceNumber]) {
            acc[raceNumber] = [];
        }
        acc[raceNumber].push(result);
        return acc;
    }, {});

    const raceStats = [];
    let overallHighestScore = -Infinity;
    let overallLargestGap = 0;
    let bestRaceForScore = null;
    let bestRaceForGap = null;

    // Calculate stats for each race
    Object.keys(raceGroups).forEach(raceNumber => {
        const horses = raceGroups[raceNumber];
        const scores = horses.map(horse => horse.score);
        
        const sortedScores = [...scores].sort((a, b) => b - a); // Sort scores highest to lowest
        const highestScore = sortedScores[0];
        const secondHighestScore = sortedScores[1] || 0; // Handle case with only 1 horse
        const gap = highestScore - secondHighestScore;
        
        // Find the horse with highest score in this race
        const topHorse = horses.find(horse => horse.score === highestScore);
        
        raceStats.push({
            raceNumber: parseInt(raceNumber),
            highestScore: highestScore,
            secondHighestScore: secondHighestScore,
            gap: gap,
            topHorse: topHorse.horse['horse name'],
            horseCount: horses.length
        });

        // Track overall meeting stats
        if (highestScore > overallHighestScore) {
            overallHighestScore = highestScore;
            bestRaceForScore = {
                raceNumber: raceNumber,
                horseName: topHorse.horse['horse name'],
                score: highestScore
            };
        }

        if (gap > overallLargestGap) {
            overallLargestGap = gap;
            bestRaceForGap = {
                raceNumber: raceNumber,
                gap: gap,
                highestScore: highestScore,
                secondHighestScore: secondHighestScore
            };
        }
    });

    // Sort race stats by race number
    raceStats.sort((a, b) => a.raceNumber - b.raceNumber);

    return {
        raceStats: raceStats,
        overallHighestScore: overallHighestScore,
        overallLargestGap: overallLargestGap,
        bestRaceForScore: bestRaceForScore,
        bestRaceForGap: bestRaceForGap,
        totalRaces: raceStats.length
    };
}

function createDashboard(stats) {
    const dashboard = document.createElement('div');
    dashboard.style.cssText = `
        background: #2d2d2d;
        color: black;
        padding: 20px;
        border-radius: 12px;
        margin-bottom: 25px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
    `;

    // Overall meeting stats
    const overallStats = document.createElement('div');
    overallStats.style.cssText = `
        display: flex;
        justify-content: space-around;
        margin-bottom: 20px;
        flex-wrap: wrap;
        gap: 15px;
    `;

    const createStatCard = (title, value, subtitle = '') => {
        const card = document.createElement('div');
        card.style.cssText = `
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            min-width: 150px;
            backdrop-filter: blur(10px);
        `;
        
        card.innerHTML = `
            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px; color: white;">${title}</div>
            <div style="font-size: 24px; font-weight: bold; margin-bottom: 5px; color: white;">${value}</div>
            ${subtitle ? `<div style="font-size: 12px; opacity: 0.8; color: white;">${subtitle}</div>` : ''}
        `;
        return card;
    };

    // Add overall stats cards
    overallStats.appendChild(createStatCard(
        'Meeting High Score', 
        stats.overallHighestScore.toFixed(1),
        `${stats.bestRaceForScore.horseName} (Race ${stats.bestRaceForScore.raceNumber})`
    ));

    overallStats.appendChild(createStatCard(
        'Largest Score Gap', 
        stats.overallLargestGap.toFixed(1),
        `Race ${stats.bestRaceForGap.raceNumber}`
    ));

    overallStats.appendChild(createStatCard(
        'Total Races', 
        stats.totalRaces
    ));

    dashboard.appendChild(overallStats);

    // Race-by-race breakdown
    const raceBreakdown = document.createElement('div');
    raceBreakdown.innerHTML = '<h3 style="margin: 0 0 15px 0; font-size: 18px;">Race Breakdown</h3>';
    
    const raceTable = document.createElement('table');
    raceTable.style.cssText = `
        width: 100%;
        border-collapse: collapse;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        overflow: hidden;
    `;

    // Create race table header
    const raceHeaderRow = raceTable.insertRow();
    raceHeaderRow.style.background = 'rgba(255, 255, 255, 0.2)';
    ['Race', 'Top Horse', 'High Score', 'Score Gap', 'Horses'].forEach(text => {
        const cell = raceHeaderRow.insertCell();
        cell.innerText = text;
        cell.style.cssText = 'padding: 10px; font-weight: bold; text-align: center;';
    });

    // Populate race table
    stats.raceStats.forEach(raceStat => {
        const row = raceTable.insertRow();
        row.style.cssText = 'border-bottom: 1px solid rgba(255, 255, 255, 0.1);';
        
        // Race number
        const raceCell = row.insertCell();
        raceCell.innerText = raceStat.raceNumber;
        raceCell.style.cssText = 'padding: 8px; text-align: center; font-weight: bold;';

        // Top horse
        const horseCell = row.insertCell();
        horseCell.innerText = raceStat.topHorse;
        horseCell.style.cssText = 'padding: 8px; text-align: left;';

        // High score
        const scoreCell = row.insertCell();
        scoreCell.innerText = raceStat.highestScore.toFixed(1);
        scoreCell.style.cssText = 'padding: 8px; text-align: center; font-weight: bold;';
        
        // Highlight if this is the meeting high score
        if (raceStat.highestScore === stats.overallHighestScore) {
            scoreCell.style.background = 'rgba(0, 255, 0, 0.3)';
            scoreCell.style.border = '2px solid green';
        }

        // Score gap
        const gapCell = row.insertCell();
        gapCell.innerText = raceStat.gap.toFixed(1);
        gapCell.style.cssText = 'padding: 8px; text-align: center;';
        
        // Highlight if this is the largest gap
        if (raceStat.gap === stats.overallLargestGap) {
            gapCell.style.background = 'rgba(0, 255, 0, 0.3)';
            gapCell.style.border = '2px solid green';
        }

        // Horse count
        const countCell = row.insertCell();
        countCell.innerText = raceStat.horseCount;
        countCell.style.cssText = 'padding: 8px; text-align: center;';
    });

    raceBreakdown.appendChild(raceTable);
    dashboard.appendChild(raceBreakdown);

    return dashboard;
}

function generatePDF(fileName, dashboardStats, raceGroups, isAdvanced) {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    
    // Title
    const meetingName = fileName.replace('.csv', '');
    doc.setFontSize(18);
    doc.setFont(undefined, 'bold');
    doc.text(meetingName, 14, 20);
    
    // Subtitle
    doc.setFontSize(12);
    doc.setFont(undefined, 'normal');
    doc.text('Partington Probability Engine Analysis', 14, 28);
    
    let yPosition = 40;
    
    // Meeting Summary
    doc.setFontSize(14);
    doc.setFont(undefined, 'bold');
    doc.text('Meeting Summary', 14, yPosition);
    yPosition += 8;
    
    doc.setFontSize(10);
    doc.setFont(undefined, 'normal');
    doc.text(`Meeting High Score: ${dashboardStats.overallHighestScore.toFixed(1)} - ${dashboardStats.bestRaceForScore.horseName} (Race ${dashboardStats.bestRaceForScore.raceNumber})`, 14, yPosition);
    yPosition += 6;
    doc.text(`Largest Score Gap: ${dashboardStats.overallLargestGap.toFixed(1)} points (Race ${dashboardStats.bestRaceForGap.raceNumber})`, 14, yPosition);
    yPosition += 6;
    doc.text(`Total Races: ${dashboardStats.totalRaces}`, 14, yPosition);
    yPosition += 12;
    
    // Race Breakdown Summary Table
    doc.setFontSize(12);
    doc.setFont(undefined, 'bold');
    doc.text('Race Breakdown', 14, yPosition);
    yPosition += 6;
    
    const summaryTableData = dashboardStats.raceStats.map(raceStat => [
        raceStat.raceNumber,
        raceStat.topHorse,
        raceStat.highestScore.toFixed(1),
        raceStat.gap.toFixed(1),
        raceStat.horseCount
    ]);
    
    doc.autoTable({
        startY: yPosition,
        head: [['Race', 'Top Horse', 'High Score', 'Gap', 'Horses']],
        body: summaryTableData,
        theme: 'striped',
        headStyles: { fillColor: [45, 45, 45], textColor: [255, 255, 255], fontStyle: 'bold' },
        styles: { fontSize: 9, cellPadding: 3 },
        columnStyles: {
            0: { halign: 'center', fontStyle: 'bold' },
            2: { halign: 'center' },
            3: { halign: 'center' },
            4: { halign: 'center' }
        }
    });
    
    // Get position after summary table
    yPosition = doc.lastAutoTable.finalY + 15;
    
    // Sort race numbers
    const sortedRaceNumbers = Object.keys(raceGroups).sort((a, b) => parseInt(a) - parseInt(b));
    
    // Add each race details
    sortedRaceNumbers.forEach((raceNum, index) => {
        const raceResults = raceGroups[raceNum];
        
        // Add new page if needed
        if (yPosition > 250 || index > 0) {
            doc.addPage();
            yPosition = 20;
        }
        
        // Race header
        doc.setFontSize(14);
        doc.setFont(undefined, 'bold');
        doc.text(`Race ${raceNum}`, 14, yPosition);
        yPosition += 8;
        
        // Build table headers
        const headers = ['Pos', 'Horse Name', 'Score', 'Odds'];
        if (isAdvanced) {
            headers.push('Win Prob.', 'Perf. Prob.', 'Base Prob.');
        }
        headers.push('Notes');
        
        // Build table data
        const tableData = raceResults.map((result, idx) => {
            const row = [
                idx + 1,
                result.horse['horse name'],
                result.score.toFixed(1),
                result.trueOdds
            ];
            
            if (isAdvanced) {
                row.push(
                    result.winProbability,
                    result.performanceComponent,
                    result.baseProbability
                );
            }
            
            row.push(result.notes);
            return row;
        });
        
        // Create table
        doc.autoTable({
            startY: yPosition,
            head: [headers],
            body: tableData,
            theme: 'grid',
            headStyles: { 
                fillColor: [102, 126, 234], 
                textColor: [255, 255, 255],
                fontStyle: 'bold',
                fontSize: 9
            },
            styles: { 
                fontSize: 8,
                cellPadding: 2
            },
            columnStyles: {
                0: { halign: 'center', cellWidth: 12 },
                2: { halign: 'center', fontStyle: 'bold' },
                3: { halign: 'center' }
            },
            didParseCell: function(data) {
                // Highlight top 3 positions
                if (data.section === 'body' && data.column.index === 0) {
                    const position = parseInt(data.cell.text[0]);
                    if (position === 1) {
                        data.cell.styles.fillColor = [46, 213, 115]; // Green
                        data.cell.styles.textColor = [255, 255, 255];
                        data.cell.styles.fontStyle = 'bold';
                    } else if (position === 2) {
                        data.cell.styles.fillColor = [255, 234, 167]; // Yellow
                    } else if (position === 3) {
                        data.cell.styles.fillColor = [255, 159, 67]; // Orange
                    }
                }
            }
        });
        
        yPosition = doc.lastAutoTable.finalY + 15;
    });
    
    // Add footer to all pages
    const pageCount = doc.internal.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        doc.setFont(undefined, 'normal');
        doc.setTextColor(150);
        doc.text(`Generated by Partington Probability Engine - Page ${i} of ${pageCount}`, 14, 285);
        doc.text(new Date().toLocaleString(), 200, 285, { align: 'right' });
    }
    
    // Save the PDF
    doc.save(`${meetingName}_Analysis.pdf`);
}

    </script>
</body>
</html>
